#!/usr/bin/python
# -*- coding: utf-8 -*-

################################################################################
#
#   RMG - Reaction Mechanism Generator
#
#   Copyright (c) 2002-2010 Prof. William H. Green (whgreen@mit.edu) and the
#   RMG Team (rmg_dev@mit.edu)
#
#   Permission is hereby granted, free of charge, to any person obtaining a
#   copy of this software and associated documentation files (the 'Software'),
#   to deal in the Software without restriction, including without limitation
#   the rights to use, copy, modify, merge, publish, distribute, sublicense,
#   and/or sell copies of the Software, and to permit persons to whom the
#   Software is furnished to do so, subject to the following conditions:
#
#   The above copyright notice and this permission notice shall be included in
#   all copies or substantial portions of the Software.
#
#   THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
#   DEALINGS IN THE SOFTWARE.
#
################################################################################

"""
This module contains the main execution functionality for Reaction Mechanism
Generator (RMG).
"""

import os.path
import sys
import logging
import time
import shutil
import numpy
import csv
import gc
import copy

from rmgpy.constraints import failsSpeciesConstraints
from rmgpy.molecule import Molecule
from rmgpy.solver.base import TerminationTime, TerminationConversion
from rmgpy.solver.simple import SimpleReactor
from rmgpy.data.rmg import RMGDatabase
from rmgpy.data.base import ForbiddenStructureException, DatabaseError
from rmgpy.data.kinetics.library import KineticsLibrary, LibraryReaction
from rmgpy.data.kinetics.family import KineticsFamily, TemplateReaction

from rmgpy.kinetics.diffusionLimited import diffusionLimiter

from model import Species, CoreEdgeReactionModel
from pdep import PDepNetwork
import rmgpy.util as util

from rmgpy.chemkin import ChemkinWriter
from rmgpy.rmg.output import OutputHTMLWriter
from rmgpy.rmg.listener import SimulationProfileWriter, SimulationProfilePlotter
from rmgpy.restart import RestartWriter
from rmgpy.qm.main import QMDatabaseWriter
from rmgpy.stats import ExecutionStatsWriter
from rmgpy.thermo.thermoengine import submit
from rmgpy.tools.sensitivity import plotSensitivity
from cantera import ck2cti

################################################################################

solvent = None

class RMG(util.Subject):
    """
    A representation of a Reaction Mechanism Generator (RMG) job. The 
    attributes are:
    
    =================================== ================================================
    Attribute                           Description
    =================================== ================================================
    `inputFile`                         The path to the input file
    ----------------------------------- ------------------------------------------------
    `databaseDirectory`                 The directory containing the RMG database
    `thermoLibraries`                   The thermodynamics libraries to load
    `reactionLibraries`                 The kinetics libraries to load
    `statmechLibraries`                 The statistical mechanics libraries to load
    `seedMechanisms`                    The seed mechanisms included in the model
    `kineticsFamilies`                  The kinetics families to use for reaction generation
    `kineticsDepositories`              The kinetics depositories to use for looking up kinetics in each family
    `kineticsEstimator`                 The method to use to estimate kinetics: 'group additivity' or 'rate rules'
    `solvent`                           If solvation estimates are required, the name of the solvent.
    ----------------------------------- ------------------------------------------------
    `reactionModel`                     The core-edge reaction model generated by this job
    `reactionSystems`                   A list of the reaction systems used in this job
    `database`                          The RMG database used in this job
    ----------------------------------- ------------------------------------------------
    `absoluteTolerance`                 The absolute tolerance used in the ODE/DAE solver
    `relativeTolerance`                 The relative tolerance used in the ODE/DAE solver
    `sensitivityAbsoluteTolerance`      The absolute tolerance used in the ODE/DAE solver for the sensitivities
    `sensitivityRelativeTolerance`      The relative tolerance used in the ODE/DAE solver for the sensitivities
    `fluxToleranceKeepInEdge`           The relative species flux below which species are discarded from the edge
    `fluxToleranceMoveToCore`           The relative species flux above which species are moved from the edge to the core
    `fluxToleranceInterrupt`            The relative species flux above which the simulation will halt
    `maximumEdgeSpecies`                The maximum number of edge species allowed at any time
    `minCoreSizeForPrune`               Minimum number of core species before pruning is allowed
    `minSpeciesExistIterationsForPrune` Minimum number of iterations a species must exist before it can be pruned
    `filterReactions`                   Specify whether to filter reactions during model enlarging step
    `unimolecularThreshold`             Array of flags indicating whether a species is above the unimolecular reaction threshold
    `bimolecularaThreshold`             Array of flags indicating whether two species are above the bimolecular reaction threshold
    `unimolecularReact`                 Array of flags indicating whether a species should react unimolecularly in the enlarge step
    `bimolecularReact`                  Array of flags indicating whether two species should react in the enlarge step
    `termination`                       A list of termination targets (i.e :class:`TerminationTime` and :class:`TerminationConversion` objects)
    `speciesConstraints`                Dictates the maximum number of atoms, carbons, electrons, etc. generated by RMG
    ----------------------------------- ------------------------------------------------
    `outputDirectory`                   The directory used to save output files
    `verbosity`                         The level of logging verbosity for console output
    `loadRestart`                       ``True`` if restarting a previous job, ``False`` otherwise
    `saveRestartPeriod`                 The time period to periodically save a restart file (:class:`Quantity`), or ``None`` for never.
    `units`                             The unit system to use to save output files (currently must be 'si')
    `generateOutputHTML`                ``True`` to draw pictures of the species and reactions, saving a visualized model in an output HTML file.  ``False`` otherwise
    `generatePlots`                     ``True`` to generate plots of the job execution statistics after each iteration, ``False`` otherwise
    `verboseComments`                   ``True`` to keep the verbose comments for database estimates, ``False`` otherwise
    `saveEdgeSpecies`                   ``True`` to save chemkin and HTML files of the edge species, ``False`` otherwise
    `keepIrreversible`                  ``True`` to keep ireversibility of library reactions as is ('<=>' or '=>'). ``False`` (default) to force all library reactions to be reversible ('<=>')
    `pressureDependence`                Whether to process unimolecular (pressure-dependent) reaction networks
    `quantumMechanics`                  Whether to apply quantum mechanical calculations instead of group additivity to certain molecular types.
    `wallTime`                          The maximum amount of CPU time in the form DD:HH:MM:SS to expend on this job; used to stop gracefully so we can still get profiling information
    `kineticsdatastore`                 ``True`` if storing details of each kinetic database entry in text file, ``False`` otherwise
    ----------------------------------- ------------------------------------------------
    `initializationTime`                The time at which the job was initiated, in seconds since the epoch (i.e. from time.time())
    `done`                              Whether the job has completed (there is nothing new to add)
    =================================== ================================================
    
    """
    
    def __init__(self, inputFile=None, outputDirectory=None):
        super(RMG, self).__init__()
        self.inputFile = inputFile
        self.outputDirectory = outputDirectory
        self.clear()
    
    def clear(self):
        """
        Clear all loaded information about the job (except the file paths).
        """
        self.databaseDirectory = None
        self.thermoLibraries = None
        self.transportLibraries = None
        self.reactionLibraries = None
        self.statmechLibraries = None
        self.seedMechanisms = None
        self.kineticsFamilies = None
        self.kineticsDepositories = None
        self.kineticsEstimator = 'group additivity'
        self.solvent = None
        self.diffusionLimiter = None
        
        self.reactionModel = None
        self.reactionSystems = None
        self.database = None
        
        self.fluxToleranceKeepInEdge = 0.0
        self.fluxToleranceMoveToCore = 1.0
        self.fluxToleranceInterrupt = 1.0
        self.absoluteTolerance = 1.0e-8
        self.relativeTolerance = 1.0e-4
        self.sensitivityAbsoluteTolerance = 1.0e-6
        self.sensitivityRelativeTolerance = 1.0e-4
        self.maximumEdgeSpecies = 1000000
        self.minCoreSizeForPrune = 50
        self.minSpeciesExistIterationsForPrune = 2
        self.filterReactions=False
        self.unimolecularReact = None
        self.bimolecularReact = None
        self.unimolecularThreshold = None
        self.bimolecularThreshold = None
        self.termination = []
        
        self.done = False
        self.verbosity = logging.INFO
        self.loadRestart = None
        self.saveRestartPeriod = None
        self.units = 'si'
        self.generateOutputHTML = None
        self.generatePlots = None
        self.saveSimulationProfiles = None
        self.verboseComments = None
        self.saveEdgeSpecies = None
        self.keepIrreversible = None
        self.pressureDependence = None
        self.quantumMechanics = None
        self.speciesConstraints = {}
        self.wallTime = '00:00:00:00'
        self.initializationTime = 0
        self.kineticsdatastore = None

        self.execTime = []
    
    def loadInput(self, path=None):
        """
        Load an RMG job from the input file located at `inputFile`, or
        from the `inputFile` attribute if not given as a parameter.
        """
        from input import readInputFile
        if path is None: path = self.inputFile
        readInputFile(path, self)
        self.reactionModel.kineticsEstimator = self.kineticsEstimator
        # If the output directory is not yet set, then set it to the same
        # directory as the input file by default
        if not self.outputDirectory:
            self.outputDirectory = os.path.dirname(path)
        if self.pressureDependence:
            self.pressureDependence.outputFile = self.outputDirectory
            self.reactionModel.pressureDependence = self.pressureDependence

        self.reactionModel.verboseComments = self.verboseComments
        self.reactionModel.saveEdgeSpecies = self.saveEdgeSpecies
        
        if self.quantumMechanics:
            self.reactionModel.quantumMechanics = self.quantumMechanics
            
    def loadThermoInput(self, path=None):
        """
        Load an Thermo Estimation job from a thermo input file located at `inputFile`, or
        from the `inputFile` attribute if not given as a parameter.
        """
        from input import readThermoInputFile
        if path is None: path = self.inputFile
        if not self.outputDirectory:
            self.outputDirectory = os.path.dirname(path)
        readThermoInputFile(path, self)
        
        if self.quantumMechanics:
            self.reactionModel.quantumMechanics = self.quantumMechanics
        
    def checkInput(self):
        """
        Check for a few common mistakes in the input file.
        """
        if self.pressureDependence:
            for index, reactionSystem in enumerate(self.reactionSystems):
                assert (reactionSystem.T.value_si < self.pressureDependence.Tmax.value_si), "Reaction system T is above pressureDependence range."
                assert (reactionSystem.T.value_si > self.pressureDependence.Tmin.value_si), "Reaction system T is below pressureDependence range."
                assert (reactionSystem.P.value_si < self.pressureDependence.Pmax.value_si), "Reaction system P is above pressureDependence range."
                assert (reactionSystem.P.value_si > self.pressureDependence.Pmin.value_si), "Reaction system P is below pressureDependence range."
            assert any([not s.reactive for s in reactionSystem.initialMoleFractions.keys()]), \
                "Pressure Dependence calculations require at least one inert (nonreacting) species for the bath gas."

    def checkLibraries(self):
        """
        Check unwanted use of libraries:
        Liquid phase libraries in Gas phase simulation.
        Loading a Liquid phase library obtained in another solvent than the one defined in the input file.
        Other checks can be added here.
        """
        #Liquid phase simulation checks
        if self.solvent:
            #check thermo librairies
            for libIter in self.database.thermo.libraries.iterkeys():
                if self.database.thermo.libraries[libIter].solvent:
                    if not self.solvent ==  self.database.thermo.libraries[libIter].solvent:
                        raise DatabaseError('''Thermo library "{2}" was obtained in "{1}" and cannot be used with this liquid phase simulation in "{0}"
                        '''.format(self.solvent, self.database.thermo.libraries[libIter].solvent, self.database.thermo.libraries[libIter].name))   
            #Check kinetic librairies
            for libIter in self.database.kinetics.libraries.iterkeys():
                if self.database.kinetics.libraries[libIter].solvent:
                    if not self.solvent ==  self.database.kinetics.libraries[libIter].solvent:
                        raise DatabaseError('''Kinetics library "{2}" was obtained in "{1}" and cannot be used with this liquid phase simulation in "{0}"
                        '''.format(self.solvent, self.database.kinetics.libraries[libIter].solvent, self.database.kinetics.libraries[libIter].name))
        #Gas phase simulation checks
        else:
            #check thermo librairies
            for libIter in self.database.thermo.libraries.iterkeys():
                if self.database.thermo.libraries[libIter].solvent:
                    raise DatabaseError('''Thermo library "{1}" was obtained in "{0}" solvent and cannot be used in gas phase simulation
                    '''.format(self.database.thermo.libraries[libIter].solvent, self.database.thermo.libraries[libIter].name))   
            #Check kinetic librairies
            for libIter in self.database.kinetics.libraries.iterkeys():
                if self.database.kinetics.libraries[libIter].solvent:
                    raise DatabaseError('''Kinetics library "{1}" was obtained in "{0}" solvent and cannot be used in gas phase simulation
                    '''.format(self.database.kinetics.libraries[libIter].solvent, self.database.kinetics.libraries[libIter].name))
    
    def saveInput(self, path=None):
        """
        Save an RMG job to the input file located at `path`, or
        from the `outputFile` attribute if not given as a parameter.
        """
        from input import saveInputFile
        if path is None: path = self.outputFile
        saveInputFile(path, self)
        
    def loadDatabase(self):
        
        self.database = RMGDatabase()
        self.database.load(
            path = self.databaseDirectory,
            thermoLibraries = self.thermoLibraries,
            transportLibraries = self.transportLibraries,
            reactionLibraries = [library for library, option in self.reactionLibraries],
            seedMechanisms = self.seedMechanisms,
            kineticsFamilies = self.kineticsFamilies,
            kineticsDepositories = self.kineticsDepositories,
            #frequenciesLibraries = self.statmechLibraries,
            depository = False, # Don't bother loading the depository information, as we don't use it
        )
        
        #check libraries
        self.checkLibraries()
        
        #set global variable solvent
        if self.solvent:
            global solvent
            solvent=self.solvent
        
        if self.kineticsEstimator == 'rate rules':
            if '!training' not in self.kineticsDepositories:
                logging.info('Adding rate rules from training set in kinetics families...')
                # Temporarily remove species constraints for the training reactions
                copySpeciesConstraints=copy.copy(self.speciesConstraints)
                self.speciesConstraints={}
                for family in self.database.kinetics.families.values():
                    family.addKineticsRulesFromTrainingSet(thermoDatabase=self.database.thermo)

                    #If requested by the user, write a text file for each kinetics family detailing the source of each entry
                    if self.kineticsdatastore:
                        logging.info('Writing sources of kinetic entries in family {0} to text file'.format(family.label))
                        path = os.path.join(self.outputDirectory, 'kinetics_database', family.label + '.txt')
                        with open(path, 'w') as f:
                            for template_label, entries in family.rules.entries.iteritems():
                                f.write("Template [{0}] uses the {1} following source(s):\n".format(template_label,str(len(entries))))
                                for entry_index, entry in enumerate(entries):
                                    f.write(str(entry_index+1) + ". " + entry.shortDesc + "\n" + entry.longDesc + "\n")
                                f.write('\n')
                            f.write('\n')

                self.speciesConstraints=copySpeciesConstraints
            else:
                logging.info('Training set explicitly not added to rate rules in kinetics families...')
            logging.info('Filling in rate rules in kinetics families by averaging...')
            for family in self.database.kinetics.families.values():
                family.fillKineticsRulesByAveragingUp(verbose=self.verboseComments)
    
    def initialize(self, **kwargs):
        """
        Initialize an RMG job using the command-line arguments `args` as returned
        by the :mod:`argparse` package.
        """
    
        # Save initialization time
        self.initializationTime = time.time()
    
        # Log start timestamp
        logging.info('RMG execution initiated at ' + time.asctime() + '\n')
    
        # Print out RMG header
        self.logHeader()
        
        try:
            restart = kwargs['restart']
        except KeyError:
            restart = False

        if restart:
            if not os.path.exists(os.path.join(self.outputDirectory,'restart.pkl')):
                logging.error("Could not find restart file (restart.pkl). Please run without --restart option.")
                raise Exception("No restart file")
            
        # Read input file
        self.loadInput(self.inputFile)

        # Check input file 
        self.checkInput()
    
        # See if memory profiling package is available
        try:
            import psutil
        except ImportError:
            logging.info('Optional package dependency "psutil" not found; memory profiling information will not be saved.')
    
        
        # Make output subdirectories
        util.makeOutputSubdirectory(self.outputDirectory, 'pdep')
        util.makeOutputSubdirectory(self.outputDirectory, 'solver')
        util.makeOutputSubdirectory(self.outputDirectory, 'kinetics_database')

        # Specifies if details of kinetic database entries should be stored according to user
        try:
            self.kineticsdatastore = kwargs['kineticsdatastore']
        except KeyError:
            self.kineticsdatastore = False

        # Load databases
        self.loadDatabase()
        
        # Do all liquid-phase startup things:
        if self.solvent:
            Species.solventData = self.database.solvation.getSolventData(self.solvent)
            Species.solventName = self.solvent
            Species.solventStructure = self.database.solvation.getSolventStructure(self.solvent)
            diffusionLimiter.enable(Species.solventData, self.database.solvation)
            logging.info("Setting solvent data for {0}".format(self.solvent))

        data = self.wallTime.split(':')
        self.wallTime = int(data[-1]) + 60 * int(data[-2]) + 3600 * int(data[-3]) + 86400 * int(data[-4])
        if not len(data) == 4:
            raise ValueError('Invalid format for wall time; should be DD:HH:MM:SS.')

        # Initialize reaction model
        if restart:
            self.initializeRestartRun(os.path.join(self.outputDirectory,'restart.pkl'))
        else:
    
            # Seed mechanisms: add species and reactions from seed mechanism
            # DON'T generate any more reactions for the seed species at this time
            for seedMechanism in self.seedMechanisms:
                self.reactionModel.addSeedMechanismToCore(seedMechanism, react=False)

            # Reaction libraries: add species and reactions from reaction library to the edge so
            # that RMG can find them if their rates are large enough
            for library, option in self.reactionLibraries:
                self.reactionModel.addReactionLibraryToEdge(library)
                
            # Also always add in a few bath gases (since RMG-Java does)
            for label, smiles in [('Ar','[Ar]'), ('He','[He]'), ('Ne','[Ne]'), ('N2','N#N')]:
                molecule = Molecule().fromSMILES(smiles)
                spec, isNew = self.reactionModel.makeNewSpecies(molecule, label=label, reactive=False)
                if isNew:
                    self.initialSpecies.append(spec)
            
            # Perform species constraints and forbidden species checks on input species
            for spec in self.initialSpecies:
                if self.database.forbiddenStructures.isMoleculeForbidden(spec.molecule[0]):
                    if 'allowed' in self.speciesConstraints and 'input species' in self.speciesConstraints['allowed']:
                        logging.warning('Input species {0} is globally forbidden.  It will behave as an inert unless found in a seed mechanism or reaction library.'.format(spec.label))
                    else:
                        raise ForbiddenStructureException("Input species {0} is globally forbidden. You may explicitly allow it, but it will remain inert unless found in a seed mechanism or reaction library.".format(spec.label))
                if failsSpeciesConstraints(spec):
                    if 'allowed' in self.speciesConstraints and 'input species' in self.speciesConstraints['allowed']:
                        self.speciesConstraints['explicitlyAllowedMolecules'].append(spec.molecule[0])
                        pass
                    else:
                        raise ForbiddenStructureException("Species constraints forbids input species {0}. Please reformulate constraints, remove the species, or explicitly allow it.".format(spec.label))

            # For liquidReactor, checks whether the solvent is listed as one of the initial species.
            if self.solvent:
                self.database.solvation.checkSolventinInitialSpecies(self,Species.solventStructure)

            #Check to see if user has input Singlet O2 into their input file or libraries
            #This constraint is special in that we only want to check it once in the input instead of every time a species is made
            if 'allowSingletO2' in self.speciesConstraints and self.speciesConstraints['allowSingletO2']:
                pass
            else:
                #Here we get a list of all species that from the user input
                allInputtedSpecies=[spec for spec in self.initialSpecies]
                #Because no iterations have taken place, the only things in the core are from seed mechanisms
                allInputtedSpecies.extend(self.reactionModel.core.species)
                #Because no iterations have taken place, the only things in the edge are from reaction libraries
                allInputtedSpecies.extend(self.reactionModel.edge.species)
                
                O2Singlet=Molecule().fromSMILES('O=O')
                for spec in allInputtedSpecies:
                    if spec.isIsomorphic(O2Singlet):
                        raise ForbiddenStructureException("""Species constraints forbids input species {0}
                        RMG expects the triplet form of oxygen for correct usage in reaction families. Please change your input to SMILES='[O][O]'
                        If you actually want to use the singlet state, set the allowSingletO2=True inside of the Species Constraints block in your input file.
                        """.format(spec.label))

            for spec in self.initialSpecies:
                submit(spec)
                
            # Add nonreactive species (e.g. bath gases) to core first
            # This is necessary so that the PDep algorithm can identify the bath gas            
            for spec in self.initialSpecies:
                if not spec.reactive:
                    self.reactionModel.enlarge(spec)
            for spec in self.initialSpecies:
                if spec.reactive:
                    self.reactionModel.enlarge(spec)
            
            #chatelak: store constant SPC indices in the reactor attributes if any constant SPC provided in the input file
            #advantages to write it here: this is run only once (as species indexes does not change over the generation)
            if self.solvent is not None:
                for index, reactionSystem in enumerate(self.reactionSystems):
                    if reactionSystem.constSPCNames is not None: #if no constant species provided do nothing
                        reactionSystem.get_constSPCIndices(self.reactionModel.core.species)  ##call the function to identify indices in the solver         
                                  
            self.initializeReactionThresholdAndReactFlags()


        self.reactionModel.initializeIndexSpeciesDict()
            

    def register_listeners(self):
        """
        Attaches listener classes depending on the options 
        found in the RMG input file.
        """

        self.attach(ChemkinWriter(self.outputDirectory))

        if self.generateOutputHTML:
            self.attach(OutputHTMLWriter(self.outputDirectory))

        if self.saveRestartPeriod:
            self.attach(RestartWriter()) 

        if self.quantumMechanics:
            self.attach(QMDatabaseWriter()) 

        self.attach(ExecutionStatsWriter(self.outputDirectory))

        if self.saveSimulationProfiles:

            for index, reactionSystem in enumerate(self.reactionSystems):
                reactionSystem.attach(SimulationProfileWriter(
                    self.outputDirectory, index, self.reactionModel.core.species))   
                reactionSystem.attach(SimulationProfilePlotter(
                    self.outputDirectory, index, self.reactionModel.core.species))  
        

    def execute(self, **kwargs):
        """
        Execute an RMG job using the command-line arguments `args` as returned
        by the :mod:`argparse` package.
        """
    
        self.initialize(**kwargs)

        # register listeners
        self.register_listeners()

        self.done = False
        
        # Initiate first reaction discovery step after adding all core species
        if self.filterReactions:
            # Run the reaction system to update threshold and react flags
            for index, reactionSystem in enumerate(self.reactionSystems):
                reactionSystem.initializeModel(
                    coreSpecies = self.reactionModel.core.species,
                    coreReactions = self.reactionModel.core.reactions,
                    edgeSpecies = [],
                    edgeReactions = [],
                    pdepNetworks = self.reactionModel.networkList,
                    atol = self.absoluteTolerance,
                    rtol = self.relativeTolerance,
                    filterReactions=True,
                )
                self.updateReactionThresholdAndReactFlags(
                    rxnSysUnimolecularThreshold=reactionSystem.unimolecularThreshold, 
                    rxnSysBimolecularThreshold=reactionSystem.bimolecularThreshold)

        self.reactionModel.enlarge(reactEdge=True, 
            unimolecularReact=self.unimolecularReact, 
            bimolecularReact=self.bimolecularReact)

        logging.info('Completed initial enlarge edge step...')
        self.saveEverything()
        
        # Main RMG loop
        while not self.done:
                
            self.done = True
            objectsToEnlarge = []
            allTerminated = True
            numCoreSpecies = len(self.reactionModel.core.species)
            for index, reactionSystem in enumerate(self.reactionSystems):
                
                # Conduct simulation
                logging.info('Conducting simulation of reaction system %s...' % (index+1))
                prune = True
                if numCoreSpecies < self.minCoreSizeForPrune:
                    # Turn pruning off if we haven't reached minimum core size.
                    prune = False
                    
                try: terminated, obj = reactionSystem.simulate(
                    coreSpecies = self.reactionModel.core.species,
                    coreReactions = self.reactionModel.core.reactions,
                    edgeSpecies = self.reactionModel.edge.species,
                    edgeReactions = self.reactionModel.edge.reactions,
                    toleranceKeepInEdge = self.fluxToleranceKeepInEdge if prune else 0,
                    toleranceMoveToCore = self.fluxToleranceMoveToCore,
                    toleranceInterruptSimulation = self.fluxToleranceInterrupt if prune else self.fluxToleranceMoveToCore,
                    pdepNetworks = self.reactionModel.networkList,
                    absoluteTolerance = self.absoluteTolerance,
                    relativeTolerance = self.relativeTolerance,
                    filterReactions=False,
                )
                except:
                    logging.error("Model core reactions:")
                    if len(self.reactionModel.core.reactions) > 5:
                        logging.error("Too many to print in detail")
                    else:
                        from rmgpy.cantherm.output import prettify
                        logging.error(prettify(repr(self.reactionModel.core.reactions)))
                    raise
                allTerminated = allTerminated and terminated
                logging.info('')
                
                # If simulation is invalid, note which species should be added to
                # the core
                if obj:
                    if isinstance(obj, PDepNetwork):
                        # Determine which species in that network has the highest leak rate
                        # We do this here because we need a temperature and pressure
                        # Store the maximum leak species along with the associated network
                        obj = (obj, obj.getMaximumLeakSpecies(reactionSystem.T.value_si, reactionSystem.P.value_si))
                    objectsToEnlarge.append(obj)
                    self.done = False
    
    
            if not self.done: # There is something that needs exploring/enlarging
                
                # If we reached our termination conditions, then try to prune
                # species from the edge
                if allTerminated:
                    self.reactionModel.prune(self.reactionSystems, self.fluxToleranceKeepInEdge, self.maximumEdgeSpecies, self.minSpeciesExistIterationsForPrune)
                    # Perform garbage collection after pruning
                    collected = gc.collect()
                    logging.info('Garbage collector: collected %d objects.' % (collected))
    
                # Enlarge objects identified by the simulation for enlarging
                # These should be Species or Network objects
                logging.info('')
                objectsToEnlarge = list(set(objectsToEnlarge))

                if len(objectsToEnlarge) == 0:
                    raise Exception("Expected a species or pdep object to enlarge, but there wasn't one found.")
                
                # Add objects to enlarge to the core first
                for objectToEnlarge in objectsToEnlarge:
                    self.reactionModel.enlarge(objectToEnlarge)
                
                if len(self.reactionModel.core.species) > numCoreSpecies:
                    # If there were core species added, then react the edge
                    # If there were no new core species, it means the pdep network needs be updated through another enlarge core step
                    if self.filterReactions:
                        # Run a raw simulation to get updated reaction system threshold values
                        for index, reactionSystem in enumerate(self.reactionSystems):
                            # Run with the same conditions as with pruning off
                            reactionSystem.simulate(
                                coreSpecies = self.reactionModel.core.species,
                                coreReactions = self.reactionModel.core.reactions,
                                edgeSpecies = [],
                                edgeReactions = [],
                                toleranceKeepInEdge = 0,
                                toleranceMoveToCore = self.fluxToleranceMoveToCore,
                                toleranceInterruptSimulation = self.fluxToleranceMoveToCore,
                                pdepNetworks = self.reactionModel.networkList,
                                absoluteTolerance = self.absoluteTolerance,
                                relativeTolerance = self.relativeTolerance,
                                filterReactions=True,
                            )
                            self.updateReactionThresholdAndReactFlags(
                                rxnSysUnimolecularThreshold = reactionSystem.unimolecularThreshold,
                                rxnSysBimolecularThreshold = reactionSystem.bimolecularThreshold)
    
                        logging.info('')    
                    else:
                        self.updateReactionThresholdAndReactFlags()
                    
                    self.reactionModel.enlarge(reactEdge=True, 
                            unimolecularReact=self.unimolecularReact, 
                            bimolecularReact=self.bimolecularReact)

            self.saveEverything()

            # Consider stopping gracefully if the next iteration might take us
            # past the wall time
            if self.wallTime > 0 and len(self.execTime) > 1:
                t = self.execTime[-1]
                dt = self.execTime[-1] - self.execTime[-2]
                if t + 3 * dt > self.wallTime:
                    logging.info('MODEL GENERATION TERMINATED')
                    logging.info('')
                    logging.info('There is not enough time to complete the next iteration before the wall time is reached.')
                    logging.info('The output model may be incomplete.')
                    logging.info('')
                    coreSpec, coreReac, edgeSpec, edgeReac = self.reactionModel.getModelSize()
                    logging.info('The current model core has %s species and %s reactions' % (coreSpec, coreReac))
                    logging.info('The current model edge has %s species and %s reactions' % (edgeSpec, edgeReac))
                    return
        
        
        # Run sensitivity analysis post-model generation if sensitivity analysis is on
        for index, reactionSystem in enumerate(self.reactionSystems):
            
            if reactionSystem.sensitiveSpecies:
                logging.info('Conducting sensitivity analysis of reaction system %s...' % (index+1))
                    
                sensWorksheet = []
                for spec in reactionSystem.sensitiveSpecies:
                    csvfilePath = os.path.join(self.outputDirectory, 'solver', 'sensitivity_{0}_SPC_{1}.csv'.format(index+1, spec.index))
                    sensWorksheet.append(csvfilePath)
                    
                terminated, obj = reactionSystem.simulate(
                    coreSpecies = self.reactionModel.core.species,
                    coreReactions = self.reactionModel.core.reactions,
                    edgeSpecies = self.reactionModel.edge.species,
                    edgeReactions = self.reactionModel.edge.reactions,
                    toleranceKeepInEdge = self.fluxToleranceKeepInEdge,
                    toleranceMoveToCore = self.fluxToleranceMoveToCore,
                    toleranceInterruptSimulation = self.fluxToleranceInterrupt,
                    pdepNetworks = self.reactionModel.networkList,
                    absoluteTolerance = self.absoluteTolerance,
                    relativeTolerance = self.relativeTolerance,
                    sensitivity = True,
                    sensitivityAbsoluteTolerance = self.sensitivityAbsoluteTolerance,
                    sensitivityRelativeTolerance = self.sensitivityRelativeTolerance,
                    sensWorksheet = sensWorksheet,
                )
                
                plotSensitivity(self.outputDirectory, index, reactionSystem.sensitiveSpecies)

        # generate Cantera files chem.cti & chem_annotated.cti in a designated `cantera` output folder
        try:
            self.generateCanteraFiles(os.path.join(self.outputDirectory, 'chemkin', 'chem.inp'))
            self.generateCanteraFiles(os.path.join(self.outputDirectory, 'chemkin', 'chem_annotated.inp'))
        except EnvironmentError:
            logging.error('Could not generate Cantera files due to EnvironmentError. Check read\write privileges in output directory.')
                
        # Write output file
        logging.info('')
        logging.info('MODEL GENERATION COMPLETED')
        logging.info('')
        coreSpec, coreReac, edgeSpec, edgeReac = self.reactionModel.getModelSize()
        logging.info('The final model core has %s species and %s reactions' % (coreSpec, coreReac))
        logging.info('The final model edge has %s species and %s reactions' % (edgeSpec, edgeReac))
        
        self.finish()

    def generateCanteraFiles(self, chemkinFile, **kwargs):
        """
        Convert a chemkin mechanism chem.inp file to a cantera mechanism file chem.cti
        and save it in the cantera directory
        """
        transportFile = os.path.join(os.path.dirname(chemkinFile), 'tran.dat')
        fileName = os.path.splitext(os.path.basename(chemkinFile))[0] + '.cti'
        outName = os.path.join(self.outputDirectory, 'cantera', fileName)
        canteraDir = os.path.dirname(outName)
        try:
            os.makedirs(canteraDir)
        except OSError:
            if not os.path.isdir(canteraDir):
                raise
        if os.path.exists(outName):
            os.remove(outName)
        parser = ck2cti.Parser()
        parser.convertMech(chemkinFile, transportFile=transportFile, outName=outName, quiet=True, permissive=True, **kwargs)

    def initializeReactionThresholdAndReactFlags(self):
        numCoreSpecies = len(self.reactionModel.core.species)
        if self.filterReactions:
            self.unimolecularReact = numpy.zeros((numCoreSpecies),bool)
            self.bimolecularReact = numpy.zeros((numCoreSpecies, numCoreSpecies),bool)
            self.unimolecularThreshold = numpy.zeros((numCoreSpecies),bool)
            self.bimolecularThreshold = numpy.zeros((numCoreSpecies, numCoreSpecies),bool)
        else:
            # By default, react everything
            self.unimolecularReact = numpy.ones((numCoreSpecies),bool)
            self.bimolecularReact = numpy.ones((numCoreSpecies, numCoreSpecies),bool)
            # No need to initialize reaction threshold arrays in this case

    def updateReactionThresholdAndReactFlags(self, rxnSysUnimolecularThreshold=None, rxnSysBimolecularThreshold=None):
        numCoreSpecies = len(self.reactionModel.core.species)
        prevNumCoreSpecies = len(self.unimolecularReact)
        stale = True if numCoreSpecies > prevNumCoreSpecies else False
        
        
        if self.filterReactions:
            if stale:
                # Reset and expand the react arrays if there were new core species added
                self.unimolecularReact = numpy.zeros((numCoreSpecies), bool)
                self.bimolecularReact = numpy.zeros((numCoreSpecies, numCoreSpecies), bool)
                
                # Expand the threshold arrays if there were new core species added
                unimolecularThreshold = numpy.zeros((numCoreSpecies), bool)
                bimolecularThreshold = numpy.zeros((numCoreSpecies, numCoreSpecies), bool)
                # Broadcast original thresholds
                unimolecularThreshold[:prevNumCoreSpecies] = self.unimolecularThreshold
                bimolecularThreshold[:prevNumCoreSpecies,:prevNumCoreSpecies] = self.bimolecularThreshold
                self.unimolecularThreshold = unimolecularThreshold
                self.bimolecularThreshold = bimolecularThreshold
            # Always update the react and threshold arrays
            for i in xrange(numCoreSpecies):
                if not self.unimolecularThreshold[i] and rxnSysUnimolecularThreshold[i]:
                    # We've shifted from not reacting to reacting
                    self.unimolecularReact[i] = True
                    self.unimolecularThreshold[i] = True
                        
            for i in xrange(numCoreSpecies):
                for j in xrange(i, numCoreSpecies):
                    if not self.bimolecularThreshold[i,j] and rxnSysBimolecularThreshold[i,j]:
                        # We've shifted from not reacting to reacting
                        self.bimolecularReact[i,j] = True
                        self.bimolecularThreshold[i,j] = True
        else:
            # We are not filtering reactions
            if stale:
                # Reset and expand the react arrays if there were new core species added
                self.unimolecularReact = numpy.zeros((numCoreSpecies), bool)
                self.bimolecularReact = numpy.zeros((numCoreSpecies, numCoreSpecies), bool)
                
                # React all the new core species unimolecularly
                for i in xrange(prevNumCoreSpecies, numCoreSpecies):
                    self.unimolecularReact[i] = True
                
                # React all the new core species with all the core species bimolecularly
                for i in xrange(numCoreSpecies):
                    for j in xrange(prevNumCoreSpecies,numCoreSpecies):
                        self.bimolecularReact[i,j] = True

        
    def saveEverything(self):
        """
        Saves the output HTML, the Chemkin file, and the Restart file (if appropriate).
        
        The restart file is only saved if self.saveRestartPeriod or self.done.
        """
        # If the user specifies it, add unused reaction library reactions to
        # an additional output species and reaction list which is written to the ouput HTML
        # file as well as the chemkin file
        
        if self.reactionLibraries:
            # First initialize the outputReactionList and outputSpeciesList to empty
            self.reactionModel.outputSpeciesList = []
            self.reactionModel.outputReactionList = []
            for library, option in self.reactionLibraries:
                if option:
                    self.reactionModel.addReactionLibraryToOutput(library)
        
        self.execTime.append(time.time() - self.initializationTime)

        # Notify registered listeners:
        self.notify()
            
    def finish(self):
        """
        Complete the model generation.
        """
        # Log end timestamp
        logging.info('')
        logging.info('RMG execution terminated at ' + time.asctime())
    
    def getGitCommit(self, modulePath):
        import subprocess
        if os.path.exists(os.path.join(modulePath,'..','.git')):
            try:
                return subprocess.check_output(['git', 'log',
                                                '--format=%H%n%cd', '-1'],
                                                cwd=modulePath).splitlines()
            except:
                return '', ''
        else:
            return '', ''
    
    def logHeader(self, level=logging.INFO):
        """
        Output a header containing identifying information about RMG to the log.
        """
        from rmgpy import __version__, getPath, settings
        logging.log(level, '#########################################################')
        logging.log(level, '# RMG-Py - Reaction Mechanism Generator in Python       #')
        logging.log(level, '# Version: {0:44s} #'.format(__version__))
        logging.log(level, '# Authors: RMG Developers (rmg_dev@mit.edu)             #')
        logging.log(level, '# P.I.s:   William H. Green (whgreen@mit.edu)           #')
        logging.log(level, '#          Richard H. West (r.west@neu.edu)             #')
        logging.log(level, '# Website: http://reactionmechanismgenerator.github.io/ #')
        logging.log(level, '#########################################################\n')
    
        # Extract git commit from RMG-Py
        head, date = self.getGitCommit(getPath())
        if head != '' and date != '':
            logging.log(level, 'The current git HEAD for RMG-Py is:')
            logging.log(level, '\t%s' % head)
            logging.log(level, '\t%s' % date)
            logging.log(level, '')
        else:
            # If we cannot get git info, try checking if it is a conda package instead:
            condaPackage = getCondaPackage('rmg')
            if condaPackage != '':
                logging.log(level, 'The current anaconda package for RMG-Py is:')
                logging.log(level, condaPackage)
                logging.log(level,'')
                
        databaseHead, databaseDate = self.getGitCommit(settings['database.directory'])
        if databaseHead !='' and databaseDate !='':
            logging.log(level, 'The current git HEAD for RMG-database is:')
            logging.log(level, '\t%s' % databaseHead)
            logging.log(level, '\t%s' % databaseDate)
            logging.log(level, '')
        else:
            databaseCondaPackage=getCondaPackage('rmgdatabase')
            if databaseCondaPackage != '':
                logging.log(level, 'The current anaconda package for RMG-database is:')
                logging.log(level, databaseCondaPackage)
                logging.log(level,'')

    def initializeRestartRun(self, path):

        from rmgpy.rmg.model import getFamilyLibraryObject

        # read restart file
        self.loadRestartFile(path)

        # A few things still point to the species in the input file, so update
        # those to point to the equivalent species loaded from the restart file
    
        # The termination conversions still point to the old species
        from rmgpy.solver.base import TerminationConversion
        for reactionSystem in self.reactionSystems:
            for term in reactionSystem.termination:
                if isinstance(term, TerminationConversion):
                    term.species, isNew = self.reactionModel.makeNewSpecies(term.species.molecule[0], term.species.label, term.species.reactive)
    
        # The initial mole fractions in the reaction systems still point to the old species
        for reactionSystem in self.reactionSystems:
            initialMoleFractions = {}
            for spec0, moleFrac in reactionSystem.initialMoleFractions.iteritems():
                spec, isNew = self.reactionModel.makeNewSpecies(spec0.molecule[0], spec0.label, spec0.reactive)
                initialMoleFractions[spec] = moleFrac
            reactionSystem.initialMoleFractions = initialMoleFractions
    
        # The reactions and reactionDict still point to the old reaction families
        reactionDict = {}
        oldFamilies = self.reactionModel.reactionDict.keys()
        for family0_label in self.reactionModel.reactionDict:
    
            # Find the equivalent library or family in the newly-loaded kinetics database
            family_label = None
            family0_obj = getFamilyLibraryObject(family0_label)
            if isinstance(family0_obj, KineticsLibrary):
                for label, database in self.database.kinetics.libraries.iteritems():
                    if database.label == family0_label:
                        family_label = database.label
                        break
            elif isinstance(family0_obj, KineticsFamily):
                for label, database in self.database.kinetics.families.iteritems():
                    if database.label == family0_label:
                        family_label = database.label
                        break    
            else:
                import pdb; pdb.set_trace()
            if family_label is None:
                raise Exception("Unable to find matching reaction family for %s" % family0_label)
    
            # Update each affected reaction to point to that new family
            # Also use that new family in a duplicate reactionDict
            reactionDict[family_label] = {}
            for reactant1 in self.reactionModel.reactionDict[family0_label]:
                reactionDict[family_label][reactant1] = {}
                for reactant2 in self.reactionModel.reactionDict[family0_label][reactant1]:
                    reactionDict[family_label][reactant1][reactant2] = []
                    if isinstance(family0_obj, KineticsLibrary):
                        for rxn in self.reactionModel.reactionDict[family0_label][reactant1][reactant2]:
                            assert isinstance(rxn, LibraryReaction)
                            rxn.library = family_label
                            reactionDict[family_label][reactant1][reactant2].append(rxn)
                    elif isinstance(family0_obj, KineticsFamily):
                        for rxn in self.reactionModel.reactionDict[family0_label][reactant1][reactant2]:
                            assert isinstance(rxn, TemplateReaction)
                            rxn.family_label = family_label
                            reactionDict[family_label][reactant1][reactant2].append(rxn)
        
        self.reactionModel.reactionDict = reactionDict
    
    def loadRestartFile(self, path):
        """
        Load a restart file at `path` on disk.
        """
        import cPickle
    
        # Unpickle the reaction model from the specified restart file
        logging.info('Loading previous restart file...')
        f = open(path, 'rb')
        rmg_restart = cPickle.load(f)
        f.close()

        self.reactionModel = rmg_restart.reactionModel
        self.unimolecularReact = rmg_restart.unimolecularReact
        self.bimolecularReact = rmg_restart.bimolecularReact
        if self.filterReactions:
            self.unimolecularThreshold = rmg_restart.unimolecularThreshold
            self.bimolecularThreshold = rmg_restart.bimolecularThreshold
        
    def loadRMGJavaInput(self, path):
        """
        Load an RMG-Java job from the input file located at `inputFile`, or
        from the `inputFile` attribute if not given as a parameter.
        """
        
        # NOTE: This function is currently incomplete!
        # It only loads a subset of the available information.
    
        self.reactionModel = CoreEdgeReactionModel()
        self.initialSpecies = []
        self.reactionSystems = []
    
        Tlist = []; Plist = []; concentrationList = []; speciesDict = {}
        termination = []; atol=1e-16; rtol=1e-8
        
        with open(path, 'r') as f:
            line = self.readMeaningfulLineJava(f)
            while line != '':
                
                
                if line.startswith('TemperatureModel:'):
                    tokens = line.split()
                    units = tokens[2][1:-1]
                    assert units in ['C', 'F', 'K']
                    if units == 'C':
                        Tlist = [float(T)+273.15 for T in tokens[3:]]
                    elif units == 'F':
                        Tlist = [(float(T)+459.67)*5./9. for T in tokens[3:]]
                    else:
                        Tlist = [float(T) for T in tokens[3:]]
                
                elif line.startswith('PressureModel:'):
                    tokens = line.split()
                    units = tokens[2][1:-1]
                    assert units in ['atm', 'bar', 'Pa', 'torr']
                    if units == 'atm':
                        Plist = [float(P)*101325. for P in tokens[3:]]
                    elif units == 'bar':
                        Plist = [float(P)*100000. for P in tokens[3:]]
                    elif units == 'torr':
                        Plist = [float(P)/760.*101325. for P in tokens[3:]]
                    else:
                        Plist = [float(P) for P in tokens[3:]]
                        
                elif line.startswith('InitialStatus:'):
                    label = ''; concentrations = []; adjlist = ''
                    
                    line = self.readMeaningfulLineJava(f)
                    while line != 'END':
                        
                        if line == '' and label != '':
                            species = Species(label=label, molecule=[Molecule().fromAdjacencyList(adjlist)])
                            self.initialSpecies.append(species)
                            speciesDict[label] = species
                            concentrationList.append(concentrations)
                            label = ''; concentrations = []; adjlist = ''
                        
                        elif line != '' and label == '':
                            tokens = line.split()
                            label = tokens[0]
                            units = tokens[1][1:-1]
                            if tokens[-1] in ['Unreactive', 'ConstantConcentration']:
                                tokens.pop(-1)
                            assert units in ['mol/cm3', 'mol/m3', 'mol/l']
                            if units == 'mol/cm3':
                                concentrations = [float(C)*1.0e6 for C in tokens[2:]]
                            elif units == 'mol/l':
                                concentrations = [float(C)*1.0e3 for C in tokens[2:]]
                            else:
                                concentrations = [float(C) for C in tokens[2:]]
                        
                        elif line != '':
                            adjlist += line + '\n'
                        
                        line = f.readline().strip()
                        if '//' in line: line = line[0:line.index('//')]
                        
                elif line.startswith('InertGas:'):
                    
                    line = self.readMeaningfulLineJava(f)
                    while line != 'END':
                        
                        tokens = line.split()
                        label = tokens[0]
                        assert label in ['N2', 'Ar', 'He', 'Ne']
                        if label == 'Ne':
                            smiles = '[Ne]'
                        elif label == 'Ar':
                            smiles = '[Ar]'
                        elif label == 'He':
                            smiles = '[He]'
                        else:
                            smiles = 'N#N'
                        units = tokens[1][1:-1]
                        assert units in ['mol/cm3', 'mol/m3', 'mol/l']
                        if units == 'mol/cm3':
                            concentrations = [float(C)*1.0e6 for C in tokens[2:]]
                        elif units == 'mol/l':
                            concentrations = [float(C)*1.0e3 for C in tokens[2:]]
                        else:
                            concentrations = [float(C) for C in tokens[2:]]
                        
                        species = Species(label=label, reactive=False, molecule=[Molecule().fromSMILES(smiles)])
                        self.initialSpecies.append(species)
                        speciesDict[label] = species
                        concentrationList.append(concentrations)
                            
                        line = self.readMeaningfulLineJava(f)
                
                elif line.startswith('FinishController:'):
                    
                    # First meaningful line is a termination time or conversion
                    line = self.readMeaningfulLineJava(f)
                    tokens = line.split()
                    if tokens[2].lower() == 'conversion:':
                        label = tokens[3]
                        conversion = float(tokens[4])
                        termination.append(TerminationConversion(spec=speciesDict[label], conv=conversion))
                    elif tokens[2].lower() == 'reactiontime:':
                        time = float(tokens[3])
                        units = tokens[4][1:-1]
                        assert units in ['sec', 'min', 'hr', 'day']
                        if units == 'min':
                            time *= 60.
                        elif units == 'hr':
                            time *= 60. * 60.
                        elif units == 'day':
                            time *= 60. * 60. * 24.
                        termination.append(TerminationTime(time=time))
                            
                    # Second meaningful line is the error tolerance
                    # We're not doing anything with this information yet!
                    line = self.readMeaningfulLineJava(f)
                 
                elif line.startswith('Atol:'):
                    tokens = line.split()
                    atol = float(tokens[1])
                    
                elif line.startswith('Rtol:'):
                    tokens = line.split()
                    rtol = float(tokens[1])
                
                line = self.readMeaningfulLineJava(f)
        
        assert len(Tlist) > 0
        assert len(Plist) > 0
        concentrationList = numpy.array(concentrationList)
        assert concentrationList.shape[1] > 0  # An arbitrary number of concentrations is acceptable, and should be run for each reactor system 
        
        # Make a reaction system for each (T,P) combination
        for T in Tlist:
            for P in Plist:
                for i in range(concentrationList.shape[1]):
                    concentrations = concentrationList[:,i]
                    totalConc = numpy.sum(concentrations)
                    initialMoleFractions = dict([(self.initialSpecies[i], concentrations[i] / totalConc) for i in range(len(self.initialSpecies))])
                    reactionSystem = SimpleReactor(T, P, initialMoleFractions=initialMoleFractions, termination=termination)
                    self.reactionSystems.append(reactionSystem)
    
    def readMeaningfulLineJava(self, f):
        """
        Read a meaningful line from an RMG-Java condition file object `f`,
        returning the line with any comments removed.
        """
        line = f.readline()
        if line != '':
            line = line.strip()
            if '//' in line: line = line[0:line.index('//')]
            while line == '':
                line = f.readline()
                if line == '': break
                line = line.strip()
                if '//' in line: line = line[0:line.index('//')]
        return line
    
################################################################################

def initializeLog(verbose, log_file_name):
    """
    Set up a logger for RMG to use to print output to stdout. The
    `verbose` parameter is an integer specifying the amount of log text seen
    at the console; the levels correspond to those of the :data:`logging` module.
    """
    # Create logger
    logger = logging.getLogger()
    logger.setLevel(verbose)

    # Create console handler and set level to debug; send everything to stdout
    # rather than stderr
    ch = logging.StreamHandler(sys.stdout)
    ch.setLevel(verbose)

    logging.addLevelName(logging.CRITICAL, 'Critical: ')
    logging.addLevelName(logging.ERROR, 'Error: ')
    logging.addLevelName(logging.WARNING, 'Warning: ')
    logging.addLevelName(logging.INFO, '')
    logging.addLevelName(logging.DEBUG, '')
    logging.addLevelName(1, '')

    # Create formatter and add to console handler
    #formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s', '%Y-%m-%d %H:%M:%S')
    #formatter = Formatter('%(message)s', '%Y-%m-%d %H:%M:%S')
    formatter = logging.Formatter('%(levelname)s%(message)s')
    ch.setFormatter(formatter)

    # create file handler
    if os.path.exists(log_file_name):
        backup = os.path.join(log_file_name[:-7], 'RMG_backup.log')
        if os.path.exists(backup):
            print "Removing old "+backup
            os.remove(backup)
        print 'Moving {0} to {1}\n'.format(log_file_name, backup)
        shutil.move(log_file_name, backup)
    fh = logging.FileHandler(filename=log_file_name) #, backupCount=3)
    fh.setLevel(min(logging.DEBUG,verbose)) # always at least VERBOSE in the file
    fh.setFormatter(formatter)
    # notice that STDERR does not get saved to the log file
    # so errors from underlying libraries (eg. openbabel) etc. that report
    # on stderr will not be logged to disk.

    # remove old handlers!
    while logger.handlers:
        logger.removeHandler(logger.handlers[0])

    # Add console and file handlers to logger
    logger.addHandler(ch)
    logger.addHandler(fh)

################################################################################

class Tee:
    """A simple tee to create a stream which prints to many streams.
    
    This is used to report the profiling statistics to both the log file
    and the standard output.
    """
    def __init__(self, *fileobjects):
        self.fileobjects=fileobjects
    def write(self, string):
        for fileobject in self.fileobjects:
            fileobject.write(string)
            
def getCondaPackage(module):
    """
    Check the version of any conda package
    """
    import subprocess
    try:
        lines = subprocess.check_output(['conda', 'list', '-f', module]).splitlines()
        
        packages=[]
        # Strip comments
        for line in lines:
            if line[:1]=='#':
                pass
            else:
                packages.append(line)
                
        return '\n'.join(packages)
    except:
        return ''

def processProfileStats(stats_file, log_file):
    import pstats
    out_stream = Tee(sys.stdout,open(log_file,'a')) # print to screen AND append to RMG.log
    print >>out_stream, "="*80
    print >>out_stream, "Profiling Data".center(80)
    print >>out_stream, "="*80
    stats = pstats.Stats(stats_file,stream=out_stream)
    stats.strip_dirs()
    print >>out_stream, "Sorted by internal time"
    stats.sort_stats('time')
    stats.print_stats(25)
    stats.print_callers(25)
    print >>out_stream, "Sorted by cumulative time"
    stats.sort_stats('cumulative')
    stats.print_stats(25)
    stats.print_callers(25)
    stats.print_callees(25)

def makeProfileGraph(stats_file):
    """
    Uses gprof2dot to create a graphviz dot file of the profiling information.
    
    This requires the gprof2dot package available via `pip install gprof2dot`.
    Render the result using the program 'dot' via a command like
    `dot -Tps2 input.dot -o output.ps2`.
    
    Rendering the ps2 file to pdf requires an external pdf converter
    `ps2pdf output.ps2` which produces a `output.ps2.pdf` file.
    """
    try:
        from gprof2dot import PstatsParser, DotWriter, SAMPLES, themes
    except ImportError:
        logging.warning('Trouble importing from package gprof2dot. Unable to create a graph of the profile statistics.')
        logging.warning('Try getting the latest version with something like `pip install --upgrade gprof2dot`.')
        return
    import subprocess
    
    #create an Options class to mimic optparser output as much as possible:
    class Options:
        pass
    
    options = Options()
    options.node_thres = 0.8
    options.edge_thres = 0.1
    options.strip = False
    options.show_samples = False
    options.root = ""
    options.leaf = ""
    options.wrap = True
    
    theme = themes['color'] # bw color gray pink
    theme.fontname = "ArialMT" # default "Arial" leads to PostScript warnings in dot (on Mac OS)
    parser = PstatsParser(stats_file)
    profile = parser.parse()
    
    dot_file = stats_file + '.dot'
    output = open(dot_file,'wt')
    dot = DotWriter(output)
    dot.strip = options.strip
    dot.wrap = options.wrap
    
    if options.show_samples:
        dot.show_function_events.append(SAMPLES)
    
    profile = profile
    profile.prune(options.node_thres/100.0, options.edge_thres/100.0)

    if options.root:
        rootId = profile.getFunctionId(options.root)
        if not rootId:
            sys.stderr.write('root node ' + options.root + ' not found (might already be pruned : try -e0 -n0 flags)\n')
            sys.exit(1)
        profile.prune_root(rootId)
    if options.leaf:
        leafId = profile.getFunctionId(options.leaf)
        if not leafId:
            sys.stderr.write('leaf node ' + options.leaf + ' not found (maybe already pruned : try -e0 -n0 flags)\n')
            sys.exit(1)
        profile.prune_leaf(leafId)

    dot.graph(profile, theme)

    output.close()
    
    try:
        subprocess.check_call(['dot', '-Tps2', dot_file, '-o', '{0}.ps2'.format(dot_file)])
    except subprocess.CalledProcessError:
        logging.error("Error returned by 'dot' when generating graph of the profile statistics.")
        logging.info("To try it yourself:\n     dot -Tps2 {0} -o {0}.ps2".format(dot_file))
    except OSError:
        logging.error("Couldn't run 'dot' to create graph of profile statistics. Check graphviz is installed properly and on your path.")
        logging.info("Once you've got it, try:\n     dot -Tps2 {0} -o {0}.ps2".format(dot_file))
    
    try:
        subprocess.check_call(['ps2pdf', '{0}.ps2'.format(dot_file), '{0}.pdf'.format(dot_file)])
    except OSError:
        logging.error("Couldn't run 'ps2pdf' to create pdf graph of profile statistics. Check that ps2pdf converter is installed.")
        logging.info("Once you've got it, try:\n     pd2pdf {0}.ps2 {0}.pdf".format(dot_file))    
    else:
        logging.info("Graph of profile statistics saved to: \n {0}.pdf".format(dot_file))

