#!/usr/bin/python
# -*- coding: utf-8 -*-

################################################################################
#
#	RMG - Reaction Mechanism Generator
#
#	Copyright (c) 2002-2009 Prof. William H. Green (whgreen@mit.edu) and the
#	RMG Team (rmg_dev@mit.edu)
#
#	Permission is hereby granted, free of charge, to any person obtaining a
#	copy of this software and associated documentation files (the 'Software'),
#	to deal in the Software without restriction, including without limitation
#	the rights to use, copy, modify, merge, publish, distribute, sublicense,
#	and/or sell copies of the Software, and to permit persons to whom the
#	Software is furnished to do so, subject to the following conditions:
#
#	The above copyright notice and this permission notice shall be included in
#	all copies or substantial portions of the Software.
#
#	THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
#	DEALINGS IN THE SOFTWARE.
#
################################################################################

"""
Contains classes for working with the reaction model generated by RMG.
"""

import logging
import math
import numpy
import os.path
import itertools

from rmgpy.display import display
#import rmgpy.chemkin
import rmgpy.constants as constants
from rmgpy.quantity import Quantity
import rmgpy.species
from rmgpy.thermo import Wilhoit, NASA, ThermoData
from rmgpy.pdep import SingleExponentialDown
from rmgpy.statmech import  Conformer

from rmgpy.data.base import Entry, ForbiddenStructureException
from rmgpy.data.thermo import *
from rmgpy.data.solvation import *
from rmgpy.data.kinetics import *
from rmgpy.data.statmech import *
from rmgpy.transport import TransportData
import rmgpy.data.rmg

#needed to call the generate3dTS method in Reaction class
from rmgpy.reaction import Reaction

from pdep import PDepReaction, PDepNetwork, PressureDependenceError
# generateThermoDataFromQM under the Species class imports the qm package

#: This dictionary is used to add multiplicity to species label
_multiplicity_labels = {1:'S',2:'D',3:'T',4:'Q',5:'V',}


################################################################################

class Species(rmgpy.species.Species):
    solventName = None
    solventData = None
    solventViscosity = None
    diffusionTemp = None

    def __init__(self, index=-1, label='', multiplicity=103, thermo=None, conformer=None, 
                 molecule=None, transportData=None, molecularWeight=None, 
                 dipoleMoment=None, polarizability=None, Zrot=None, 
                 energyTransferModel=None, reactive=True, coreSizeAtCreation=0):
        rmgpy.species.Species.__init__(self, index, label, multiplicity, thermo, conformer, molecule, transportData, molecularWeight, dipoleMoment, polarizability, Zrot, energyTransferModel, reactive)
        self.coreSizeAtCreation = coreSizeAtCreation

    def __reduce__(self):
        """
        A helper function used when pickling an object.
        """
        return (Species, (self.index, self.label, self.thermo, self.conformer, self.molecule, self.transportData, self.molecularWeight, self.dipoleMoment, self.polarizability, self.Zrot, self.energyTransferModel, self.reactive, self.coreSizeAtCreation),)

    def generateThermoData(self, database, thermoClass=NASA, quantumMechanics=None):
        """
        Generates thermo data, first checking Libraries, then using either QM or Database.
        
        If quantumMechanics is not None, it is asked to calculate the thermo.
        Failing that, the database is used.
        
        The database generates the thermo data for each structure (resonance isomer),
        picks that with lowest H298 value.
        
        It then calls :meth:`processThermoData`, to convert (via Wilhoit) to NASA
        and set the E0.
        
        Result stored in `self.thermo` and returned.
        """
        from rmgpy.data.thermo import saveEntry

        thermo0 = None
        
        thermo0 = database.thermo.getThermoDataFromLibraries(self)
        
        if thermo0 is not None:
            logging.info("Found thermo for {0} in thermo library".format(self.label))
            assert len(thermo0) == 3, "thermo0 should be a tuple at this point: (thermoData, library, entry)"
            thermo0 = thermo0[0]
            
        elif quantumMechanics:
            molecule = self.molecule[0]
            if quantumMechanics.settings.onlyCyclics and not molecule.isCyclic():
                pass
            else: # try a QM calculation
                if molecule.getRadicalCount() > quantumMechanics.settings.maxRadicalNumber:
                    # Too many radicals for direct calculation: use HBI.
                    logging.info("{0} radicals on {1} exceeds limit of {2}. Using HBI method.".format(
                        self.molecule[0].getRadicalCount(),
                        self.label,
                        quantumMechanics.settings.maxRadicalNumber,
                        ))
                    
                    # Need to estimate thermo via each resonance isomer
                    thermo = []
                    for molecule in self.molecule:
                        molecule.clearLabeledAtoms()
                        tdata = database.thermo.estimateRadicalThermoViaHBI(molecule, quantumMechanics.getThermoData)
                        if tdata is not None:
                            thermo.append(tdata)
                    if thermo:
                        H298 = numpy.array([t.getEnthalpy(298.) for t in thermo])
                        indices = H298.argsort()
                        for i, ind in enumerate(indices):
                            logging.info("Resonance isomer {0} {1} gives H298={2:.0f} J/mol".format(i, self.molecule[ind].toSMILES(), H298[ind]))
                        self.molecule = [self.molecule[ind] for ind in indices]
                        molecule = self.molecule[0]
                        thermo0 = thermo[indices[0]]
                    else:
                        pass
                    
                    with open('thermoHBIcheck.txt','a') as f:
                        f.write('// {0!r}\n'.format(thermo0).replace('),','),\n//           '))
                        f.write('{0}\n'.format(molecule.toSMILES()))
                        f.write('{0}\n\n'.format(molecule.toAdjacencyList(removeH=False)))
                else: # Not too many radicals: do a direct calculation.
                    thermo0 = quantumMechanics.getThermoData(molecule) # returns None if it fails
                
                if thermo0 is not None:
                    # Write the QM molecule thermo to a library so that can be used in future RMG jobs.
                    quantumMechanics.database.loadEntry(index = len(quantumMechanics.database.entries) + 1,
                                                        label = molecule.toSMILES() + '_({0})'.format(_multiplicity_labels[molecule.multiplicity]),
                                                        multiplicity = molecule.multiplicity,
                                                        molecule = molecule.toAdjacencyList(),
                                                        thermo = thermo0,
                                                        shortDesc = thermo0.comment
                                                        )                    
        if thermo0 is None:
            thermo0 = database.thermo.getThermoData(self)

        return self.processThermoData(database, thermo0, thermoClass)

    def processThermoData(self, database, thermo0, thermoClass=NASA):
        """
        Converts via Wilhoit into required `thermoClass` and sets `E0`.
        
        Resulting thermo is stored (`self.thermo`) and returned.
        """

        # Always convert to Wilhoit so we can compute E0
        if isinstance(thermo0, Wilhoit):
            wilhoit = thermo0
        elif isinstance(thermo0, ThermoData):
            Tdata = thermo0._Tdata.value_si
            Cpdata = thermo0._Cpdata.value_si
            H298 = thermo0._H298.value_si
            S298 = thermo0._S298.value_si
            Cp0 = thermo0._Cp0.value_si
            CpInf = thermo0._CpInf.value_si
            wilhoit = Wilhoit().fitToDataForConstantB(Tdata, Cpdata, Cp0, CpInf, H298, S298, B=1000.0)
        else:
            Cp0 = self.calculateCp0()
            CpInf = self.calculateCpInf()
            wilhoit = thermo0.toWilhoit(Cp0=Cp0, CpInf=CpInf)
        wilhoit.comment = thermo0.comment

        # Add on solvation correction
        if Species.solventData:
            #logging.info("Making solvent correction for {0}".format(Species.solventName))
            soluteData = database.solvation.getSoluteData(self)
            solvation_correction = database.solvation.getSolvationCorrection(soluteData, Species.solventData)
            # correction is added to the entropy and enthalpy
            wilhoit.S0.value_si = (wilhoit.S0.value_si + solvation_correction.entropy)
            wilhoit.H0.value_si = (wilhoit.H0.value_si + solvation_correction.enthalpy)
            
        # Compute E0 by extrapolation to 0 K
        if self.conformer is None:
            self.conformer = Conformer()
        self.conformer.E0 = (wilhoit.getEnthalpy(1.0)*1e-3,"kJ/mol")
        
        # Convert to desired thermo class
        if isinstance(thermo0, thermoClass):
            self.thermo = thermo0
            # If we don't have an E0, copy it across from the Wilhoit that was fitted
            if self.thermo.E0 is None:
                self.thermo.E0 = wilhoit.E0
        elif isinstance(wilhoit, thermoClass):
            self.thermo = wilhoit
        else:
            self.thermo = wilhoit.toNASA(Tmin=100.0, Tmax=5000.0, Tint=1000.0)
        
        if self.thermo.__class__ != thermo0.__class__:
            # Compute RMS error of overall transformation
            Tlist = numpy.array([300.0, 400.0, 500.0, 600.0, 800.0, 1000.0, 1500.0], numpy.float64)
            err = 0.0
            for T in Tlist:
                err += (self.thermo.getHeatCapacity(T) - thermo0.getHeatCapacity(T))**2
            err = math.sqrt(err/len(Tlist))/constants.R
            logging.log(logging.WARNING if err > 0.2 else 0, 'Average RMS error in heat capacity fit to {0} = {1:g}*R'.format(self, err))

        return self.thermo

    def generateStatMech(self, database):
        """
        Generate molecular degree of freedom data for the species. You must
        have already provided a thermodynamics model using e.g.
        :meth:`generateThermoData()`.
        """
        if not self.hasThermo():
            raise Exception("Unable to determine statmech model for species {0}: No thermodynamics model found.".format(self))
        molecule = self.molecule[0]
        conformer = database.statmech.getStatmechData(molecule, self.thermo)
        if self.conformer is None:
            self.conformer = Conformer()
        self.conformer.E0 = self.thermo.E0
        self.conformer.modes = conformer.modes
        self.conformer.spinMultiplicity = conformer.spinMultiplicity
            
    def generateTransportData(self, database):
        """
        Generate the transportData parameters for the species.
        """
        #count = sum([1 for atom in self.molecule[0].vertices if atom.isNonHydrogen()])
        self.transportData = database.transport.getTransportProperties(self)[0]
        

        #previous method for calculating transport properties
        '''
        if count == 1:
            self.transportData.sigma = (3.758e-10,"m")
            self.transportData.epsilon = (148.6,"K")
        elif count == 2:
            self.transportData.sigma = (4.443e-10,"m")
            self.transportData.epsilon = (110.7,"K")
        elif count == 3:
            self.transportData.sigma = (5.118e-10,"m")
            self.transportData.epsilon = (237.1,"K")
        elif count == 4:
            self.transportData.sigma = (4.687e-10,"m")
            self.transportData.epsilon = (531.4,"K")
        elif count == 5:
            self.transportData.sigma = (5.784e-10,"m")
            self.transportData.epsilon = (341.1,"K")
        else:
            self.transportData.sigma = (5.949e-10,"m")
            self.transportData.epsilon = (399.3,"K")
        '''
    
    def generateEnergyTransferModel(self):
        """
        Generate the collisional energy transfer model parameters for the
        species. This "algorithm" is *very* much in need of improvement.
        """
        self.energyTransferModel = SingleExponentialDown(
            alpha0 = (300*0.011962,"kJ/mol"),
            T0 = (300,"K"),
            n = 0.85,
        )

################################################################################

class ReactionModel:
    """
    Represent a generic reaction model. A reaction model consists of `species`,
    a list of species, and `reactions`, a list of reactions.
    """

    def __init__(self, species=None, reactions=None):
        self.species = species or []
        self.reactions = reactions or []

################################################################################

class CoreEdgeReactionModel:
    """
    Represent a reaction model constructed using a rate-based screening
    algorithm. The species and reactions in the model itself are called the
    *core*; the species and reactions identified as candidates for inclusion in
    the model are called the *edge*. The attributes are:

    =========================  ==============================================================
    Attribute                  Description
    =========================  ==============================================================
    `core`                     The species and reactions of the current model core
    `edge`                     The species and reactions of the current model edge
    `networkDict`              A dictionary of pressure-dependent reaction networks (:class:`Network` objects) indexed by source.
    `networkList`              A list of pressure-dependent reaction networks (:class:`Network` objects)
    `networkCount`             A counter for the number of pressure-dependent networks created
    =========================  ==============================================================


    """

    def __init__(self, core=None, edge=None):
        if core is None:
            self.core = ReactionModel()
        else:
            self.core = core
        if edge is None:
            self.edge = ReactionModel()
        else:
            self.edge = edge
        # The default tolerances mimic the original RMG behavior; no edge
        # pruning takes place, and the simulation is interrupted as soon as
        # a species flux higher than the validity
        self.networkDict = {}
        self.networkList = []
        self.networkCount = 0
        self.speciesDict = {}
        self.reactionDict = {}
        self.speciesCache = [None for i in range(4)]
        self.speciesCounter = 0
        self.reactionCounter = 0
        self.newSpeciesList = []
        self.newReactionList = []
        self.outputSpeciesList = []
        self.outputReactionList = []
        self.pressureDependence = None
        self.quantumMechanics = None
        self.verboseComments = False
        self.kineticsEstimator = 'group additivity'
        self.speciesConstraints = {}

    def checkForExistingSpecies(self, molecule):
        """
        Check to see if an existing species contains the same
        :class:`structure.Structure` as `structure`. Returns ``True`` or
        ``False`` and the matched species (if found, or ``None`` if not).
        """

        # First check cache and return if species is found
        for i, spec in enumerate(self.speciesCache):
            if spec is not None:
                for mol in spec.molecule:
                    if molecule.isIsomorphic(mol):
                        self.speciesCache.pop(i)
                        self.speciesCache.insert(0, spec)
                        return True, spec

        # Return an existing species if a match is found
        formula = molecule.getFormula()
        try:
             speciesList = self.speciesDict[formula]
        except KeyError:
            return False, None
        for spec in speciesList:
            if spec.isIsomorphic(molecule):
                self.speciesCache.pop()
                self.speciesCache.insert(0, spec)
                return True, spec
        # At this point we can conclude that the structure does not exist
        return False, None

    def makeNewSpecies(self, object, multiplicity, label='', reactive=True, checkForExisting=True):
        """
        Formally create a new species from the specified `object`, which can be
        either a :class:`Molecule` object or an :class:`rmgpy.species.Species`
        object.
        """
        if isinstance(object, rmgpy.species.Species):
            molecule = object.molecule[0]
            label = label if label != '' else object.label
            reactive = object.reactive
        else:
            molecule = object
            
        molecule.clearLabeledAtoms()
        molecule.multiplicity = multiplicity

        # If desired, check to ensure that the species is new; return the
        # existing species if not new
        if checkForExisting:
            found, spec = self.checkForExistingSpecies(molecule)
            if found: return spec, False

        # Check that the structure is not forbidden

        # If we're here then we're ready to make the new species
        if label == '': 
            # Use SMILES as default format for label
            # However, SMILES can contain slashes (to describe the
            # stereochemistry around double bonds); since RMG doesn't 
            # distinguish cis and trans isomers, we'll just strip these out
            # so that we can use the label in file paths
            label = molecule.toSMILES().replace('/','').replace('\\','')
        logging.debug('Creating new species {0}'.format(label))
        spec = Species(index=self.speciesCounter+1, label=label, multiplicity=multiplicity, molecule=[molecule], reactive=reactive)
        spec.coreSizeAtCreation = len(self.core.species)
        spec.generateResonanceIsomers()
        spec.molecularWeight = Quantity(spec.molecule[0].getMolecularWeight()*1000.,"amu")
        # spec.generateTransportData(database)
        spec.generateEnergyTransferModel()
        formula = molecule.getFormula()
        if formula in self.speciesDict:
            self.speciesDict[formula].append(spec)
        else:
            self.speciesDict[formula] = [spec]

        self.speciesCounter += 1

        # Since the species is new, add it to the list of new species
        self.newSpeciesList.append(spec)

        return spec, True

    def checkForExistingReaction(self, rxn):
        """
        Check to see if an existing reaction has the same reactants, products, and
        family as `rxn`. Returns :data:`True` or :data:`False` and the matched
        reaction (if found).
        """

        # Make sure the reactant and product lists are sorted before performing the check
        rxn.reactants.sort()
        rxn.products.sort()

        # Get the short-list of reactions with the same family, reactant1 and reactant2
        r1 = rxn.reactants[0]
        if len(rxn.reactants)==1: r2 = None
        else: r2 = rxn.reactants[1]
        family = rxn.family
        try:
            my_reactionList = self.reactionDict[family][r1][r2][:]
        except KeyError: # no such short-list: must be new, unless in seed.
            my_reactionList = []
                   
        # if the family is its own reverse (H-Abstraction) then check the other direction
        if isinstance(family,KineticsFamily) and family.ownReverse: # (family may be a KineticsLibrary)
            # Get the short-list of reactions with the same family, product1 and product2
            r1 = rxn.products[0]
            if len(rxn.products)==1: r2 = None
            else: r2 = rxn.products[1]
            family = rxn.family
            try:
                my_reactionList.extend(self.reactionDict[family][r1][r2])
            except KeyError: # no such short-list: must be new, unless in seed.
                pass

        # Now use short-list to check for matches. All should be in same forward direction.
        for rxn0 in my_reactionList:
            if (rxn0.reactants == rxn.reactants and rxn0.products == rxn.products):
                return True, rxn0
            
            if isinstance(family,KineticsFamily) and family.ownReverse:
                if (rxn0.reactants == rxn.products and rxn0.products == rxn.reactants):
                    return True, rxn0

        # Now check seed mechanisms
        # We want to check for duplicates in *other* seed mechanisms, but allow
        # duplicated *within* the same seed mechanism
        for family0 in self.reactionDict:
            if isinstance(family0, KineticsLibrary) and family0 != family:

                # First check seed short-list in forward direction
                r1 = rxn.reactants[0]
                if len(rxn.reactants)==1: r2 = None
                else: r2 = rxn.reactants[1]
                try:
                    my_reactionList = self.reactionDict[family0][r1][r2]
                except KeyError:
                    my_reactionList = []
                for rxn0 in my_reactionList:
                    if (rxn0.reactants == rxn.reactants and rxn0.products == rxn.products) or \
                        (rxn0.reactants == rxn.products and rxn0.products == rxn.reactants):
                        return True, rxn0
                # Now get the seed short-list of the reverse reaction
                r1 = rxn.products[0]
                if len(rxn.products)==1: r2 = None
                else: r2 = rxn.products[1]
                try:
                    my_reactionList = self.reactionDict[family0][r1][r2]
                except KeyError:
                    my_reactionList = []
                for rxn0 in my_reactionList:
                    if (rxn0.reactants == rxn.reactants and rxn0.products == rxn.products) or \
                        (rxn0.reactants == rxn.products and rxn0.products == rxn.reactants):
                        return True, rxn0

        return False, None

    def makeNewReaction(self, forward, checkExisting=True):
        """
        Make a new reaction given a :class:`Reaction` object `forward`. The reaction is added to the global list
        of reactions. Returns the reaction in the direction that corresponds to the
        estimated kinetics, along with whether or not the reaction is new to the
        global reaction list.

        The forward direction is determined using the "is_reverse" attribute of the
        reaction's family.  If the reaction family is its own reverse, then it is
        made such that the forward reaction is exothermic at 298K.
        
        The forward reaction is appended to self.newReactionList if it is new.
        """

        # Determine the proper species objects for all reactants and products
        reactants = [self.makeNewSpecies(reactant,reactant.multiplicity,)[0] for reactant in forward.reactants]
        products  = [self.makeNewSpecies(product,product.multiplicity,)[0]  for product  in forward.products ]
        if forward.pairs is not None:
            for pairIndex in range(len(forward.pairs)):
                reactantIndex = forward.reactants.index(forward.pairs[pairIndex][0])
                productIndex = forward.products.index(forward.pairs[pairIndex][1])
                forward.pairs[pairIndex] = (reactants[reactantIndex], products[productIndex])
                if hasattr(forward, 'reverse'):
                    forward.reverse.pairs[pairIndex] = (products[productIndex], reactants[reactantIndex])
        forward.reactants = reactants
        forward.products  = products

        if checkExisting:
            found, rxn = self.checkForExistingReaction(forward)
            if found: return rxn, False

        # Generate the reaction pairs if not yet defined
        if forward.pairs is None:
            forward.generatePairs()
            if hasattr(forward, 'reverse'):
                forward.reverse.generatePairs()
            
        # Note in the log
        if isinstance(forward, TemplateReaction):
            logging.debug('Creating new {0} template reaction {1}'.format(forward.family.label, forward))
        elif isinstance(forward, DepositoryReaction):
            logging.debug('Creating new {0} reaction {1}'.format(forward.getSource().label, forward))
        elif isinstance(forward, LibraryReaction):
            logging.debug('Creating new library reaction {0}'.format(forward))
        else:
            raise Exception("Unrecognized reaction type {0!s}".format(forward.__class__))
        
        # Add to the global dict/list of existing reactions (a list broken down by family, r1, r2)
        # identify r1 and r2
        r1 = forward.reactants[0]
        r2 = None if len(forward.reactants) == 1 else forward.reactants[1]
        family = forward.family
        # make dictionary entries if necessary
        if family not in self.reactionDict:
            self.reactionDict[family] = {}
        if not self.reactionDict[family].has_key(r1):
            self.reactionDict[family][r1] = dict()
        if not self.reactionDict[family][r1].has_key(r2):
            self.reactionDict[family][r1][r2] = list()
        # store this reaction at the top of the relevant short-list
        self.reactionDict[family][r1][r2].insert(0, forward)

        forward.index = self.reactionCounter + 1
        self.reactionCounter += 1

        # Since the reaction is new, add it to the list of new reactions
        self.newReactionList.append(forward)

        # Return newly created reaction
        return forward, True

    def makeNewPDepReaction(self, forward):
        """
        Make a new pressure-dependent reaction based on a list of `reactants` and a
        list of `products`. The reaction belongs to the specified `network` and
        has pressure-dependent kinetics given by `kinetics`.

        No checking for existing reactions is made here. The returned PDepReaction
        object is not added to the global list of reactions, as that is intended
        to represent only the high-pressure-limit set. The reactionCounter is
        incremented, however, since the returned reaction can and will exist in
        the model edge and/or core.
        """

        # Don't create reverse reaction: all such reactions are treated as irreversible
        # The reverse direction will come from a different partial network
        # Note that this isn't guaranteed to satisfy thermodynamics (but will probably be close)
        forward.reverse = None
        forward.reversible = False

        # Generate the reaction pairs if not yet defined
        if forward.pairs is None:
            forward.generatePairs()
            
        # Set reaction index and increment the counter
        forward.index = self.reactionCounter + 1
        self.reactionCounter += 1

        return forward

    def react(self, database, speciesA, speciesB=None):
        """
        Generates reactions involving :class:`rmgpy.species.Species` speciesA and speciesB.
        """
        reactionList = []
        if speciesB is None:
            for moleculeA in speciesA.molecule:
                reactionList.extend(database.kinetics.generateReactions([moleculeA], failsSpeciesConstraints=self.failsSpeciesConstraints))
                moleculeA.clearLabeledAtoms()
        else:
            for moleculeA in speciesA.molecule:
                for moleculeB in speciesB.molecule:
                    reactionList.extend(database.kinetics.generateReactions([moleculeA, moleculeB], failsSpeciesConstraints=self.failsSpeciesConstraints))
                    moleculeA.clearLabeledAtoms()
                    moleculeB.clearLabeledAtoms()
        return reactionList

    def enlarge(self, newObject):
        """
        Enlarge a reaction model by processing the objects in the list `newObject`. 
        If `newObject` is a
        :class:`rmg.species.Species` object, then the species is moved from
        the edge to the core and reactions generated for that species, reacting
        with itself and with all other species in the model core. If `newObject`
        is a :class:`rmg.unirxn.network.Network` object, then reactions are
        generated for the species in the network with the largest leak flux.
        """
        database = rmgpy.data.rmg.database
        
        if not isinstance(newObject, list):
            newObject = [newObject]
        
        numOldCoreSpecies = len(self.core.species)
        numOldCoreReactions = len(self.core.reactions)
        numOldEdgeSpecies = len(self.edge.species)
        numOldEdgeReactions = len(self.edge.reactions)
        reactionsMovedFromEdge = []
        newReactionList = []; newSpeciesList = []
            
        for obj in newObject:
            
            self.newReactionList = []; self.newSpeciesList = []
            newReactions = []
            pdepNetwork = None
            objectWasInEdge = False
        
            if isinstance(obj, Species):

                newSpecies = obj
                objectWasInEdge = newSpecies in self.edge.species
                
                if not newSpecies.reactive:
                    logging.info('NOT generating reactions for unreactive species {0}'.format(newSpecies))
                else:
                    logging.info('Adding species {0} to model core'.format(newSpecies))
                    display(newSpecies) # if running in IPython --pylab mode, draws the picture!
                    
                    # Find reactions involving the new species as unimolecular reactant
                    # or product (e.g. A <---> products)
                    newReactions.extend(self.react(database, newSpecies))
                    # Find reactions involving the new species as bimolecular reactants
                    # or products with other core species (e.g. A + B <---> products)
                    for coreSpecies in self.core.species:
                        if coreSpecies.reactive:
                            newReactions.extend(self.react(database, newSpecies, coreSpecies))
                    # Find reactions involving the new species as bimolecular reactants
                    # or products with itself (e.g. A + A <---> products)
                    newReactions.extend(self.react(database, newSpecies, newSpecies))
    
                # Add new species
                reactionsMovedFromEdge = self.addSpeciesToCore(newSpecies)
                
                # Process the new reactions
                # While adding to core/edge/pdep network, this clears atom labels:
                self.processNewReactions(newReactions, newSpecies, pdepNetwork)
    
            elif isinstance(obj, tuple) and isinstance(obj[0], PDepNetwork) and self.pressureDependence:
    
                pdepNetwork, newSpecies = obj
                newReactions.extend(pdepNetwork.exploreIsomer(newSpecies, self, database))
                self.processNewReactions(newReactions, newSpecies, pdepNetwork)
    
            else:
                raise TypeError('Unable to use object {0} to enlarge reaction model; expecting an object of class rmg.model.Species or rmg.model.PDepNetwork, not {1}'.format(obj, obj.__class__))

            # If there are any core species among the unimolecular product channels
            # of any existing network, they need to be made included
            for network in self.networkList:
                network.updateConfigurations(self)
                index = 0
                while index < len(self.core.species):
                    species = self.core.species[index]
                    isomers = [isomer.species[0] for isomer in network.isomers]
                    if species in isomers and species not in network.explored:
                        network.explored.append(species)
                        continue
                    for products in network.products:
                        products = products.species
                        if len(products) == 1 and products[0] == species:
                            newReactions = network.exploreIsomer(species, self, database)
                            self.processNewReactions(newReactions, species, network)
                            network.updateConfigurations(self)
                            index = 0
                            break
                    else:
                        index += 1
            
            if isinstance(obj, Species) and objectWasInEdge:
                # moved one species from edge to core
                numOldEdgeSpecies -= 1
                # moved these reactions from edge to core
                numOldEdgeReactions -= len(reactionsMovedFromEdge)
            
            newSpeciesList.extend(self.newSpeciesList)
            newReactionList.extend(self.newReactionList)
            
        # Generate thermodynamics of new species
        logging.info('Generating thermodynamics for new species...')
        for spec in newSpeciesList:
            spec.generateThermoData(database, quantumMechanics=self.quantumMechanics)
            spec.generateTransportData(database)
        
        # Generate kinetics of new reactions
        logging.info('Generating kinetics for new reactions...')
        for reaction in newReactionList:
            # If the reaction already has kinetics (e.g. from a library),
            # assume the kinetics are satisfactory
            if reaction.kinetics is None:
                # Set the reaction kinetics
                kinetics, source, entry, isForward = self.generateKinetics(reaction)
                reaction.kinetics = kinetics
                # Flip the reaction direction if the kinetics are defined in the reverse direction
                if not isForward:
                    reaction.reactants, reaction.products = reaction.products, reaction.reactants
                    reaction.pairs = [(p,r) for r,p in reaction.pairs]
                if reaction.family.ownReverse and hasattr(reaction,'reverse'):
                    if not isForward:
                        reaction.template = reaction.reverse.template
                    # We're done with the "reverse" attribute, so delete it to save a bit of memory
                    delattr(reaction,'reverse')
                    
        # For new reactions, convert ArrheniusEP to Arrhenius, and fix barrier heights.
        # self.newReactionList only contains *actually* new reactions, all in the forward direction.
        for reaction in newReactionList:
            # convert KineticsData to Arrhenius forms
            if isinstance(reaction.kinetics, KineticsData):
                reaction.kinetics = reaction.kinetics.toArrhenius()
            #  correct barrier heights of estimated kinetics
            if isinstance(reaction,TemplateReaction) or isinstance(reaction,DepositoryReaction): # i.e. not LibraryReaction
                reaction.fixBarrierHeight() # also converts ArrheniusEP to Arrhenius.
                
            if self.pressureDependence and reaction.isUnimolecular():
                # If this is going to be run through pressure dependence code,
                # we need to make sure the barrier is positive.
                reaction.fixBarrierHeight(forcePositive=True)
            
        # Update unimolecular (pressure dependent) reaction networks
        if self.pressureDependence:
            # Recalculate k(T,P) values for modified networks
            self.updateUnimolecularReactionNetworks(database)
            logging.info('')
            
        # Check new core reactions for Chemkin duplicates
        newCoreReactions = self.core.reactions[numOldCoreReactions:]
        checkedCoreReactions = self.core.reactions[:numOldCoreReactions]
        from rmgpy.chemkin import markDuplicateReaction
        for rxn in newCoreReactions:
            markDuplicateReaction(rxn,checkedCoreReactions)
            checkedCoreReactions.append(rxn)
        
        self.printEnlargeSummary(
            newCoreSpecies=self.core.species[numOldCoreSpecies:],
            newCoreReactions=self.core.reactions[numOldCoreReactions:],
            reactionsMovedFromEdge=reactionsMovedFromEdge,
            newEdgeSpecies=self.edge.species[numOldEdgeSpecies:],
            newEdgeReactions=self.edge.reactions[numOldEdgeReactions:]
        )

        logging.info('')

    def processNewReactions(self, newReactions, newSpecies, pdepNetwork=None):
        """
        Process a list of newly-generated reactions involving the new core
        species or explored isomer `newSpecies` in network `pdepNetwork`.
        
        Makes a reaction and decides where to put it: core, edge, or PDepNetwork.
        """
        from rmgpy.data.kinetics.library import LibraryReaction
        for rxn in newReactions:
            rxn, isNew = self.makeNewReaction(rxn)
            if isNew:
                # We've made a new reaction, so make sure the species involved
                # are in the core or edge
                allSpeciesInCore = True
                # Add the reactant and product species to the edge if necessary
                # At the same time, check if all reactants and products are in the core
                for spec in rxn.reactants:
                    if spec not in self.core.species:
                        allSpeciesInCore = False
                        if spec not in self.edge.species:
                            self.addSpeciesToEdge(spec)
                for spec in rxn.products:
                    if spec not in self.core.species:
                        allSpeciesInCore = False
                        if spec not in self.edge.species:
                            self.addSpeciesToEdge(spec)
            
            isomerAtoms = sum([len(spec.molecule[0].atoms) for spec in rxn.reactants])
            
            # Decide whether or not to handle the reaction as a pressure-dependent reaction
            pdep = True
            if not self.pressureDependence:
                # The pressure dependence option is turned off entirely
                pdep = False
            elif self.pressureDependence.maximumAtoms is not None and self.pressureDependence.maximumAtoms < isomerAtoms:
                # The reaction involves so many atoms that pressure-dependent effects are assumed to be negligible
                pdep = False
            elif not (rxn.isIsomerization() or rxn.isDissociation() or rxn.isAssociation()):
                # The reaction is not unimolecular in either direction, so it cannot be pressure-dependent
                pdep = False
            elif rxn.kinetics is not None and rxn.kinetics.isPressureDependent():
                # The reaction already has pressure-dependent kinetics (e.g. from a reaction library)
                pdep = False
                
            # If pressure dependence is on, we only add reactions that are not unimolecular;
            # unimolecular reactions will be added after processing the associated networks
            if not pdep:
                if not isNew: 
                    # The reaction is not new, so it should already be in the core or edge
                    continue
                if allSpeciesInCore:
                    #for reaction in self.core.reactions:
                    #    if isinstance(reaction, Reaction) and reaction.isEquivalent(rxn): break
                    #else:
                    self.addReactionToCore(rxn)
                else:
                    #for reaction in self.edge.reactions:
                    #    if isinstance(reaction, Reaction) and reaction.isEquivalent(rxn): break
                    #else:
                    self.addReactionToEdge(rxn)
            else:
                # Add the reaction to the appropriate unimolecular reaction network
                # If pdepNetwork is not None then that will be the network the
                # (path) reactions are added to
                # Note that this must be done even with reactions that are not new
                # because of the way partial networks are explored
                # Since PDepReactions are created as irreversible, not doing so
                # would cause you to miss the reverse reactions!
                net = self.addReactionToUnimolecularNetworks(rxn, newSpecies=newSpecies, network=pdepNetwork)
                if isinstance(rxn, LibraryReaction):
                    # If reaction came from a reaction library, omit it from the core and edge so that it does 
                    # not get double-counted with the pdep network
                    if rxn in self.core.reactions:
                        self.core.reactions.remove(rxn)
                    if rxn in self.edge.reactions:
                        self.edge.reactions.remove(rxn)

    def generateKinetics(self, reaction):
        """
        Generate best possible kinetics for the given `reaction` using the kinetics database.
        """
        # Only reactions from families should be missing kinetics
        assert isinstance(reaction, TemplateReaction)
        
        # Get the kinetics for the reaction
        kinetics, source, entry, isForward = reaction.family.getKinetics(reaction, template=reaction.template, degeneracy=reaction.degeneracy, estimator=self.kineticsEstimator, returnAllKinetics=False)
        
        # Get the enthalpy of reaction at 298 K
        H298 = reaction.getEnthalpyOfReaction(298)
        G298 = reaction.getFreeEnergyOfReaction(298)
        
        if reaction.family.ownReverse and hasattr(reaction,'reverse'):
            
            # The kinetics family is its own reverse, so we could estimate kinetics in either direction
            
            # First get the kinetics for the other direction
            rev_kinetics, rev_source, rev_entry, rev_isForward = reaction.family.getKinetics(reaction.reverse, template=reaction.reverse.template, degeneracy=reaction.reverse.degeneracy, estimator=self.kineticsEstimator, returnAllKinetics=False)

            # Now decide which direction's kinetics to keep
            keepReverse = False
            if (source is not None and rev_source is None):
                # Only the forward has a source - use forward.
                reason = "This direction matched an entry in {0}, the other was just an estimate.".format(source.label)
            elif (source is None and rev_source is not None):
                # Only the reverse has a source - use reverse.
                keepReverse = True
                reason = "This direction matched an entry in {0}, the other was just an estimate.".format(rev_source.label)
            elif (source is not None and rev_source is not None 
                  and entry is rev_entry):
                # Both forward and reverse have the same source and entry
                # Use the one for which the kinetics is the forward kinetics
                reason = "Both direction matched the same entry in {0}, which is defined in this direction.".format(source.label)
                keepReverse = not isForward
            elif self.kineticsEstimator == 'group additivity' and (kinetics.comment.find("Fitted to 1 rate")>0
                  and not rev_kinetics.comment.find("Fitted to 1 rate")>0) :
                    # forward kinetics were fitted to only 1 rate, but reverse are hopefully better
                    keepReverse = True
                    reason = "Other direction matched a group only fitted to 1 rate."
            elif self.kineticsEstimator == 'group additivity' and (not kinetics.comment.find("Fitted to 1 rate")>0
                  and rev_kinetics.comment.find("Fitted to 1 rate")>0) :
                    # reverse kinetics were fitted to only 1 rate, but forward are hopefully better
                    keepReverse = False
                    reason = "Other direction matched a group only fitted to 1 rate."
            elif entry is not None and rev_entry is not None:
                # Both directions matched explicit rate rules
                # Keep the direction with the lower (but nonzero) rank
                if entry.rank < rev_entry.rank and entry.rank != 0:
                    keepReverse = False
                    reason = "Both directions matched explicit rate rules, but this direction has a rule with a lower rank."
                elif rev_entry.rank < entry.rank and rev_entry.rank != 0:
                    keepReverse = True
                    reason = "Both directions matched explicit rate rules, but this direction has a rule with a lower rank."
                # Otherwise keep the direction that is exergonic at 298 K
                else:
                    keepReverse = G298 > 0 and isForward and rev_isForward
                    reason = "Both directions matched explicit rate rules, but this direction is exergonic."
            else:
                # Keep the direction that is exergonic at 298 K
                # This must be done after the thermo generation step
                keepReverse = G298 > 0 and isForward and rev_isForward
                reason = "Both directions are estimates, but this direction is exergonic."
            
            if keepReverse:
                kinetics = rev_kinetics
                source = rev_source
                entry = rev_entry
                isForward = not rev_isForward
                H298 = -H298
                G298 = -G298
            
            if self.verboseComments:
                kinetics.comment += "\nKinetics were estimated in this direction instead of the reverse because:\n{0}".format(reason)
                kinetics.comment += "\ndHrxn(298 K) = {0:.2f} kJ/mol, dGrxn(298 K) = {1:.2f} kJ/mol".format(H298 / 1000., G298 / 1000.)
            
        # The comments generated by the database for estimated kinetics can
        # be quite long, and therefore not very useful
        # We don't want to waste lots of memory storing these long, 
        # uninformative strings, so here we replace them with much shorter ones
        if not self.verboseComments:
            # Only keep a short comment (to save memory)
            if 'Exact' in kinetics.comment or 'Matched rule' in kinetics.comment:
                # Exact match of rate rule
                kinetics.comment = 'Exact match found for rate rule ({0})'.format(','.join([g.label for g in reaction.template])) 
            elif 'Matched reaction' in kinetics.comment:
                # Stems from matching a reaction from a depository
                pass
            else:
                # Estimated (averaged) rate rule
                kinetics.comment =  kinetics.comment[kinetics.comment.find('Estimated'):]
                
        return kinetics, source, entry, isForward
    
    def printEnlargeSummary(self, newCoreSpecies, newCoreReactions, newEdgeSpecies, newEdgeReactions, reactionsMovedFromEdge=None):
        """
        Output a summary of a model enlargement step to the log. The details of
        the enlargement are passed in the `newCoreSpecies`, `newCoreReactions`,
        `newEdgeSpecies`, and `newEdgeReactions` objects. 
        """

        logging.info('')
        logging.info('Summary of Model Enlargement')
        logging.info('----------------------------')
        logging.info('Added {0:d} new core species'.format(len(newCoreSpecies)))
        for spec in newCoreSpecies:
            display(spec)
            logging.info('    {0}'.format(spec))
        logging.info('Created {0:d} new edge species'.format(len(newEdgeSpecies)))
        for spec in newEdgeSpecies:
            display(spec)
            logging.info('    {0}'.format(spec))
        
        if reactionsMovedFromEdge:
            logging.info('Moved {0:d} reactions from edge to core'.format(len(reactionsMovedFromEdge)))
            for rxn in reactionsMovedFromEdge:
                for r in newCoreReactions:
                    if ((r.reactants == rxn.reactants and r.products == rxn.products) or
                        (r.products == rxn.reactants and r.reactants == rxn.products)):
                        logging.info('    {0}'.format(r))
                        newCoreReactions.remove(r)
                        break
                    
        logging.info('Added {0:d} new core reactions'.format(len(newCoreReactions)))
        for rxn in newCoreReactions:
            logging.info('    {0}'.format(rxn))
        logging.info('Created {0:d} new edge reactions'.format(len(newEdgeReactions)))
        for rxn in newEdgeReactions:
            logging.info('    {0}'.format(rxn))

        coreSpeciesCount, coreReactionCount, edgeSpeciesCount, edgeReactionCount = self.getModelSize()

        # Output current model size information after enlargement
        logging.info('')
        logging.info('After model enlargement:')
        logging.info('    The model core has {0:d} species and {1:d} reactions'.format(coreSpeciesCount, coreReactionCount))
        logging.info('    The model edge has {0:d} species and {1:d} reactions'.format(edgeSpeciesCount, edgeReactionCount))
        logging.info('')

    def addSpeciesToCore(self, spec):
        """
        Add a species `spec` to the reaction model core (and remove from edge if
        necessary). This function also moves any reactions in the edge that gain
        core status as a result of this change in status to the core.
        If this are any such reactions, they are returned in a list.
        """

        assert spec not in self.core.species, "Tried to add species {0} to core, but it's already there".format(spec.label)

        # Add the species to the core
        self.core.species.append(spec)
        
        rxnList = []
        if spec in self.edge.species:

            # If species was in edge, remove it
            logging.debug("Removing species {0} from edge.".format(spec))
            self.edge.species.remove(spec)

            # Search edge for reactions that now contain only core species;
            # these belong in the model core and will be moved there
            for rxn in self.edge.reactions:
                allCore = True
                for reactant in rxn.reactants:
                    if reactant not in self.core.species: allCore = False
                for product in rxn.products:
                    if product not in self.core.species: allCore = False
                if allCore: rxnList.append(rxn)

            # Move any identified reactions to the core
            for rxn in rxnList:
                self.addReactionToCore(rxn)
                logging.debug("Moving reaction from edge to core: {0}".format(rxn))
        return rxnList

    def addSpeciesToEdge(self, spec):
        """
        Add a species `spec` to the reaction model edge.
        """
        self.edge.species.append(spec)

    def prune(self, reactionSystems, fluxToleranceKeepInEdge, maximumEdgeSpecies):
        """
        Remove species from the model edge based on the simulation results from
        the list of `reactionSystems`.
        """

        ineligibleSpecies = []     # A list of the species which are not eligible for pruning, for any reason

        numCoreSpecies = len(self.core.species)
        numEdgeSpecies = len(self.edge.species)

        # All edge species that have not existed for more than two enlarge
        # iterations are ineligible for pruning
        for spec in self.edge.species:
            if numCoreSpecies - spec.coreSizeAtCreation <= 2:
                ineligibleSpecies.append(spec)

        # Get the maximum species rates (and network leak rates)
        # across all reaction systems
        maxEdgeSpeciesRates = numpy.zeros((numEdgeSpecies), numpy.float64)
        for reactionSystem in reactionSystems:
            for i in range(numEdgeSpecies):
                rate = reactionSystem.maxEdgeSpeciesRates[i]
                if maxEdgeSpeciesRates[i] < rate:
                    maxEdgeSpeciesRates[i] = rate

            for i in range(len(self.networkList)):
                network = self.networkList[i]
                rate = reactionSystem.maxNetworkLeakRates[i]
                # Add the fraction of the network leak rate contributed by
                # each unexplored species to that species' rate
                # This is to ensure we have an overestimate of that species flux
                ratios = network.getLeakBranchingRatios(reactionSystem.T.value_si,reactionSystem.P.value_si)
                for spec, frac in ratios.iteritems():
                    index = self.edge.species.index(spec)
                    maxEdgeSpeciesRates[index] += frac * rate
                # Mark any species that is explored in any partial network as ineligible for pruning
                for spec in network.explored:
                    if spec not in ineligibleSpecies:
                        ineligibleSpecies.append(spec)

        # Sort the edge species rates by index
        indices = numpy.argsort(maxEdgeSpeciesRates)

        # Determine which species to prune
        speciesToPrune = []
        pruneDueToRateCounter = 0
        for index in indices:
            # Remove the species with rates below the pruning tolerance from the model edge
            if maxEdgeSpeciesRates[index] < fluxToleranceKeepInEdge and self.edge.species[index] not in ineligibleSpecies:
                speciesToPrune.append((index, self.edge.species[index]))
                pruneDueToRateCounter += 1
            # Keep removing species with the lowest rates until we are below the maximum edge species size
            elif numEdgeSpecies - len(speciesToPrune) > maximumEdgeSpecies and self.edge.species[index] not in ineligibleSpecies:
                speciesToPrune.append((index, self.edge.species[index]))
            else:
                break

        # Actually do the pruning
        if pruneDueToRateCounter > 0:
            logging.info('Pruning {0:d} species whose rates did not exceed the minimum threshold of {1:g}'.format(pruneDueToRateCounter, fluxToleranceKeepInEdge))
            for index, spec in speciesToPrune[0:pruneDueToRateCounter]:
                logging.debug('    {0:<56}    {1:10.4e}'.format(spec, maxEdgeSpeciesRates[index]))
                self.removeSpeciesFromEdge(spec)
        if len(speciesToPrune) - pruneDueToRateCounter > 0:
            logging.info('Pruning {0:d} species to obtain an edge size of {1:d} species'.format(len(speciesToPrune) - pruneDueToRateCounter, maximumEdgeSpecies))
            for index, spec in speciesToPrune[pruneDueToRateCounter:]:
                logging.debug('    {0:<56}    {1:10.4e}'.format(spec, maxEdgeSpeciesRates[index]))
                self.removeSpeciesFromEdge(spec)

        # Delete any networks that became empty as a result of pruning
        if self.pressureDependence:
            networksToDelete = []
            if len(network.pathReactions) == 0 and len(network.netReactions) == 0:
                networksToDelete.append(network)
            if len(networksToDelete) > 0:
                logging.info('Deleting {0:d} empty pressure-dependent reaction networks'.format(len(networksToDelete)))
                for network in networksToDelete:
                    logging.debug('    Deleting empty pressure dependent reaction network #{0:d}'.format(network.index))
                    source = network.source
                    nets_with_this_source = self.networkDict[source]
                    nets_with_this_source.remove(network)
                    if not nets_with_this_source:
                        del(self.networkDict[source])
                    self.networkList.remove(network)

        logging.info('')

    def removeSpeciesFromEdge(self, spec):
        """
        Remove species `spec` from the reaction model edge.
        """

        # remove the species
        self.edge.species.remove(spec)
        # identify any reactions it's involved in
        rxnList = []
        for rxn in self.edge.reactions:
            if spec in rxn.reactants or spec in rxn.products:
                rxnList.append(rxn)
        # remove those reactions
        for rxn in rxnList:
            self.edge.reactions.remove(rxn)
        
        # Remove the species from any unirxn networks it is in
        if self.pressureDependence:
            for network in self.networkList:
                # Delete all path reactions involving the species
                rxnList = []
                for rxn in network.pathReactions:
                    if spec in rxn.reactants or spec in rxn.products:
                        rxnList.append(rxn)
                if len(rxnList) > 0:
                    for rxn in rxnList:
                        network.pathReactions.remove(rxn)
                    # Delete all net reactions involving the species
                    rxnList = []
                    for rxn in network.netReactions:
                        if spec in rxn.reactants or spec in rxn.products:
                            rxnList.append(rxn)
                    for rxn in rxnList:
                        network.netReactions.remove(rxn)
                        
                    # Recompute the isomers, reactants, and products for this network
                    network.updateConfigurations(self)

        # Remove from the global list of reactions
        # also remove it from the global list of reactions
        for family in self.reactionDict:
            if spec in self.reactionDict[family]:
                del self.reactionDict[family][spec]
            for reactant1 in self.reactionDict[family]:
                if spec in self.reactionDict[family][reactant1]:
                    del self.reactionDict[family][reactant1][spec]

        # remove from the global list of species, to free memory
        formula = spec.molecule[0].getFormula()
        self.speciesDict[formula].remove(spec)
        if spec in self.speciesCache:
            self.speciesCache.remove(spec)
            self.speciesCache.append(None)

    def addReactionToCore(self, rxn):
        """
        Add a reaction `rxn` to the reaction model core (and remove from edge if
        necessary). This function assumes `rxn` has already been checked to
        ensure it is supposed to be a core reaction (i.e. all of its reactants
        AND all of its products are in the list of core species).
        """
        if rxn not in self.core.reactions:
            self.core.reactions.append(rxn)
        if rxn in self.edge.reactions:
            self.edge.reactions.remove(rxn)
        
    def addReactionToEdge(self, rxn):
        """
        Add a reaction `rxn` to the reaction model edge. This function assumes
        `rxn` has already been checked to ensure it is supposed to be an edge
        reaction (i.e. all of its reactants OR all of its products are in the
        list of core species, and the others are in either the core or the
        edge).
        """
        if rxn not in self.edge.reactions:
            self.edge.reactions.append(rxn)

    def getModelSize(self):
        """
        Return the numbers of species and reactions in the model core and edge.
        Note that this is not necessarily equal to the lengths of the
        corresponding species and reaction lists.
        """
        coreSpeciesCount = len(self.core.species)
        coreReactionsCount = len(self.core.reactions)
        edgeSpeciesCount = len(self.edge.species)
        edgeReactionsCount = len(self.edge.reactions)
        return (coreSpeciesCount, coreReactionsCount, edgeSpeciesCount, edgeReactionsCount)

    def getLists(self):
        """
        Return lists of all of the species and reactions in the core and the
        edge.
        """
        speciesList = []
        speciesList.extend(self.core.species)
        speciesList.extend(self.edge.species)
        reactionList = []
        reactionList.extend(self.core.reactions)
        reactionList.extend(self.edge.reactions)
        return speciesList, reactionList

    def getStoichiometryMatrix(self):
        """
        Return the stoichiometry matrix for all generated species and reactions.
        The id of each species and reaction is the corresponding row and column,
        respectively, in the matrix.
        """
        speciesList, reactionList = self.getLists()
        from scipy import sparse
        stoichiometry = sparse.dok_matrix((self.speciesCounter, self.reactionCounter), float)
        for rxn in reactionList:
            j = rxn.index - 1
            specList = rxn.reactants[:]; specList.extend(rxn.products)
            for spec in specList:
                i = spec.index - 1
                nu = rxn.getStoichiometricCoefficient(spec)
                if nu != 0: stoichiometry[i,j] = nu
        return stoichiometry.tocsr()

    def getReactionRates(self, T, P, Ci):
        """
        Return an array of reaction rates for each reaction in the model core
        and edge. The id of the reaction is the index into the vector.
        """
        speciesList, reactionList = self.getLists()
        rxnRate = numpy.zeros(self.reactionCounter, float)
        for rxn in reactionList:
            j = rxn.index - 1
            rxnRate[j] = rxn.getRate(T, P, Ci)
        return rxnRate

    def addSeedMechanismToCore(self, seedMechanism, react=False):
        """
        Add all species and reactions from `seedMechanism`, a 
        :class:`KineticsPrimaryDatabase` object, to the model core. If `react`
        is ``True``, then reactions will also be generated between the seed
        species. For large seed mechanisms this can be prohibitively expensive,
        so it is not done by default.
        """

        if react: raise NotImplementedError("react=True doesn't work yet")
        database = rmgpy.data.rmg.database
        
        self.newReactionList = []; self.newSpeciesList = []

        numOldCoreSpecies = len(self.core.species)
        numOldCoreReactions = len(self.core.reactions)

        logging.info('Adding seed mechanism {0} to model core...'.format(seedMechanism))

        seedMechanism = database.kinetics.libraries[seedMechanism]

        for entry in seedMechanism.entries.values():
            rxn = LibraryReaction(reactants=entry.item.reactants[:], products=entry.item.products[:], library=seedMechanism, kinetics=entry.data)
            r, isNew = self.makeNewReaction(rxn) # updates self.newSpeciesList and self.newReactionlist
            
        # Perform species constraints and forbidden species checks
        
        for spec in self.newSpeciesList:
            if database.forbiddenStructures.isMoleculeForbidden(spec.molecule[0]):
                if 'allowed' in self.speciesConstraints and 'seed mechanisms' in self.speciesConstraints['allowed']:
                    logging.warning("Species {0} from seed mechanism {1} is globally forbidden.  It will behave as an inert unless found in a seed mechanism or reaction library.".format(spec.label, seedMechanism.label))
                else:
                    raise ForbiddenStructureException("Species {0} from seed mechanism {1} is globally forbidden. You may explicitly allow it, but it will remain inert unless found in a seed mechanism or reaction library.".format(spec.label, seedMechanism.label))
            if self.failsSpeciesConstraints(spec):
                if 'allowed' in self.speciesConstraints and 'seed mechanisms' in self.speciesConstraints['allowed']:
                    self.speciesConstraints['explicitlyAllowedMolecules'].extend(spec.molecule)
                else:
                    raise ForbiddenStructureException("Species constraints forbids species {0} from seed mechanism {1}. Please reformulate constraints, remove the species, or explicitly allow it.".format(spec.label, seedMechanism.label))

        for spec in self.newSpeciesList:            
            if spec.reactive: spec.generateThermoData(database, quantumMechanics=self.quantumMechanics)
            spec.generateTransportData(database)
            self.addSpeciesToCore(spec)

        for rxn in self.newReactionList:
            if self.pressureDependence and rxn.isUnimolecular():
                # If this is going to be run through pressure dependence code,
                # we need to make sure the barrier is positive.
                # ...but are Seed Mechanisms run through PDep? Perhaps not.
                for spec in itertools.chain(rxn.reactants, rxn.products):
                    if spec.thermo is None:
                        spec.generateThermoData(database, quantumMechanics=self.quantumMechanics)
                rxn.fixBarrierHeight(forcePositive=True)
            self.addReactionToCore(rxn)
        
        # Check we didn't introduce unmarked duplicates
        self.markChemkinDuplicates()
        
        self.printEnlargeSummary(
            newCoreSpecies=self.core.species[numOldCoreSpecies:],
            newCoreReactions=self.core.reactions[numOldCoreReactions:],
            newEdgeSpecies=[],
            newEdgeReactions=[],
        )



    def addReactionLibraryToEdge(self, reactionLibrary):
        """
        Add all species and reactions from `reactionLibrary`, a
        :class:`KineticsPrimaryDatabase` object, to the model edge.
        """

        database = rmgpy.data.rmg.database

        self.newReactionList = []
        self.newSpeciesList = []

        numOldEdgeSpecies = len(self.edge.species)
        numOldEdgeReactions = len(self.edge.reactions)

        logging.info('Adding reaction library {0} to model edge...'.format(reactionLibrary))
        reactionLibrary = database.kinetics.libraries[reactionLibrary]

        for entry in reactionLibrary.entries.values():
            rxn = LibraryReaction(reactants=entry.item.reactants[:], products=entry.item.products[:], library=reactionLibrary, kinetics=entry.data)
            r, isNew = self.makeNewReaction(rxn) # updates self.newSpeciesList and self.newReactionlist
            if not isNew: logging.info("This library reaction was not new: {0}".format(rxn))
            
        # Perform species constraints and forbidden species checks
        for spec in self.newSpeciesList:
            if database.forbiddenStructures.isMoleculeForbidden(spec.molecule[0]):
                if 'allowed' in self.speciesConstraints and 'reaction libraries' in self.speciesConstraints['allowed']:
                    logging.warning("Species {0} from reaction library {1} is globally forbidden.  It will behave as an inert unless found in a seed mechanism or reaction library.".format(spec.label, reactionLibrary.label))
                else:
                    raise ForbiddenStructureException("Species {0} from reaction library {1} is globally forbidden. You may explicitly allow it, but it will remain inert unless found in a seed mechanism or reaction library.".format(spec.label, reactionLibrary.label))
            if self.failsSpeciesConstraints(spec):
                if 'allowed' in self.speciesConstraints and 'reaction libraries' in self.speciesConstraints['allowed']:
                    self.speciesConstraints['explicitlyAllowedMolecules'].extend(spec.molecule)
                else:
                    raise ForbiddenStructureException("Species constraints forbids species {0} from reaction library {1}. Please reformulate constraints, remove the species, or explicitly allow it.".format(spec.label, reactionLibrary.label))
       
        for spec in self.newSpeciesList:
            if spec.reactive: spec.generateThermoData(database, quantumMechanics=self.quantumMechanics)
            spec.generateTransportData(database)
            self.addSpeciesToEdge(spec)

        for rxn in self.newReactionList:
            # Note that we haven't actually evaluated any fluxes at this point
            # Instead, we remove the comment below if the reaction is moved to
            # the core later in the mechanism generation
            self.addReactionToEdge(rxn)

        self.printEnlargeSummary(
            newCoreSpecies=[],
            newCoreReactions=[],
            newEdgeSpecies=self.edge.species[numOldEdgeSpecies:],
            newEdgeReactions=self.edge.reactions[numOldEdgeReactions:],
        )

    def addReactionLibraryToOutput(self, reactionLib):
        """
        Add all species and reactions from `reactionLibrary`, a
        :class:`KineticsPrimaryDatabase` object, to the output.
        This does not bring any of the reactions or species into the core itself.
        """

        logging.info('Adding reaction library {0} to output file...'.format(reactionLib))
        database = rmgpy.data.rmg.database
        reactionLibrary = database.kinetics.libraries[reactionLib]

        for entry in reactionLibrary.entries.values():
            rxn = LibraryReaction(reactants=entry.item.reactants[:], products=entry.item.products[:], library=reactionLibrary, kinetics=entry.data)
            rxn.reactants = [self.makeNewSpecies(reactant)[0] for reactant in rxn.reactants]
            rxn.products = [self.makeNewSpecies(product)[0] for product in rxn.products]

            for species in rxn.reactants:
                if species not in self.core.species and species not in self.outputSpeciesList:
                    self.outputSpeciesList.append(species)

            for species in rxn.products:
                if species not in self.core.species and species not in self.outputSpeciesList:
                    self.outputSpeciesList.append(species)

            # Reaction library was already on the edge, so we just need to get right label
            rxn = self.checkForExistingReaction(rxn)[1]
            if rxn in self.core.reactions:
                rxn.kinetics.comment = ''
                pass
            else:
                rxn.kinetics.comment = ("RMG did not find reaction rate to be high enough to be included in model core.")
                self.outputReactionList.append(rxn)
        self.markChemkinDuplicates()


    def addReactionToUnimolecularNetworks(self, newReaction, newSpecies, network=None):
        """
        Given a newly-created :class:`Reaction` object `newReaction`, update the
        corresponding unimolecular reaction network. If no network exists, a new
        one is created. If the new reaction is an isomerization that connects two
        existing networks, the two networks are merged. This function is called
        whenever a new high-pressure limit edge reaction is created. Returns the
        network containing the new reaction.
        """

        assert isinstance(newSpecies, Species)

        # Put the reaction in the direction in which the new species is in the reactants
        if newSpecies in newReaction.reactants:
            reactants = newReaction.reactants[:]
            products = newReaction.products[:]
        else:
            reactants = newReaction.products[:]
            products = newReaction.products[:]
        reactants.sort()
        products.sort()
        
        source = tuple(reactants)

        # Only search for a network if we don't specify it as a parameter
        if network is None:
            if len(reactants) == 1:
                # Find the network containing the reactant as the source
                try:
                    networks = self.networkDict[source]
                    assert len(networks) == 1
                    network = networks[0]
                except KeyError:
                    pass
            elif len(reactants) > 1:
                # Find the network containing the reactants as the source AND the
                # product as an explored isomer
                try:
                    networks = self.networkDict[source]
                    for n in networks:
                        if products[0] in n.explored:
                            assert network is None
                            network = n
                except KeyError:
                    pass
            else:
                return None

            # If no suitable network exists, create a new one
            if network is None:
                self.networkCount += 1
                network = PDepNetwork(index=self.networkCount, source=reactants[:])
                        # should the source passed to PDepNetwork constuctor be a tuple not a list? that's what is used in networkDict
                try:
                    self.networkDict[source].append(network)
                except KeyError:
                    self.networkDict[source] = [network]
                self.networkList.append(network)

        # Add the path reaction to that network
        network.addPathReaction(newReaction, newSpecies)
        
        # Return the network that the reaction was added to
        return network

    def updateUnimolecularReactionNetworks(self, database):
        """
        Iterate through all of the currently-existing unimolecular reaction
        networks, updating those that have been marked as invalid. In each update,
        the phenomonological rate coefficients :math:`k(T,P)` are computed for
        each net reaction in the network, and the resulting reactions added or
        updated.
        """

        # Merge networks if necessary
        # Two partial networks having the same source and containing one or
        # more explored isomers in common must be merged together to avoid
        # double-counting of rates
        for source, networks in self.networkDict.iteritems():
            networkCount = len(networks)
            for index0, network0 in enumerate(networks):
                index = index0 + 1
                while index < networkCount:
                    found = False
                    network = networks[index]
                    if network0.source == network.source:
                        # The networks contain the same source, but do they contain any common included isomers (other than the source)?
                        for isomer in network0.explored:
                            if isomer != network.source and isomer in network.explored:
                                # The networks contain an included isomer in common, so we need to merge them
                                found = True
                                break
                    if found:
                        # The networks contain the same source and one or more common included isomers
                        # Therefore they need to be merged together
                        logging.info('Merging PDepNetwork #{0:d} and PDepNetwork #{1:d}'.format(network0.index, network.index))
                        network0.merge(network)
                        networks.remove(network)
                        self.networkList.remove(network)
                        networkCount -= 1
                    else:
                        index += 1

        count = sum([1 for network in self.networkList if not network.valid and not (len(network.explored) == 0 and len(network.source) > 1)])
        logging.info('Updating {0:d} modified unimolecular reaction networks...'.format(count))
        
        # Iterate over all the networks, updating the invalid ones as necessary
        # self = reactionModel object
        updatedNetworks = []
        for network in self.networkList:
            if not network.valid:
                network.update(self, database, self.pressureDependence)
                updatedNetworks.append(network)
            
        # PDepReaction objects generated from partial networks are irreversible
        # However, it makes more sense to have reversible reactions in the core
        # Thus we mark PDepReaction objects as reversible and remove the reverse
        # direction from the list of core reactions
        # Note that well-skipping reactions may not have a reverse if the well
        # that they skip over is not itself in the core
        for network in updatedNetworks:
            for reaction in network.netReactions:
                try:
                    index = self.core.reactions.index(reaction)
                except ValueError:
                    continue
                for index2, reaction2 in enumerate(self.core.reactions):
                    if isinstance(reaction2, PDepReaction) and reaction.reactants == reaction2.products and reaction.products == reaction2.reactants:
                        # We've found the PDepReaction for the reverse direction
                        dGrxn = reaction.getFreeEnergyOfReaction(300.)
                        kf = reaction.getRateCoefficient(1000,1e5)
                        kr = reaction.getRateCoefficient(1000,1e5) / reaction.getEquilibriumConstant(1000)
                        kf2 = reaction2.getRateCoefficient(1000,1e5) / reaction2.getEquilibriumConstant(1000)
                        kr2 = reaction2.getRateCoefficient(1000,1e5)
                        if kf / kf2 < 0.5 or kf / kf2 > 2.0:
                            # Most pairs of reactions should satisfy thermodynamic consistency (or at least be "close")
                            # Warn about the ones that aren't close (but don't abort)
                            logging.warning('Forward and reverse PDepReactions for reaction {0!s} generated from networks {1:d} and {2:d} do not satisfy thermodynamic consistency.'.format(reaction, reaction.network.index, reaction2.network.index))
                            logging.warning('{0!s}:'.format(reaction))
                            logging.warning('{0:.2e} {1:.2e}:'.format(kf, kf2))
                            logging.warning('{0!s}:'.format(reaction2))
                            logging.warning('{0:.2e} {1:.2e}:'.format(kr, kr2))
                        # Keep the exergonic direction
                        keepFirst = dGrxn < 0
                        # Delete the PDepReaction that we aren't keeping
                        if keepFirst:
                            self.core.reactions.remove(reaction2)
                            reaction.reversible = True
                        else:
                            self.core.reactions.remove(reaction)
                            self.core.reactions.remove(reaction2)
                            self.core.reactions.insert(index, reaction2)
                            reaction2.reversible = True
                        # There should be only one reverse, so we can stop searching once we've found it
                        break
                else:
                    reaction.reversible = True

    def loadSeedMechanism(self, path):
        """
        Loads a seed mechanism from the folder indicated by `path` into the
        core-edge reaction model.
        """

        import os.path
        import quantities as pq
        import data
        import thermo.data
        import kinetics.data
        import reaction

        # Load the species data from the file species.txt
        # This file has the format of a standard RMG dictionary
        d = data.Dictionary()
        d.load(os.path.join(path, 'species.txt'))
        d.toStructure(addH=True)

        # Load the thermo data from the file thermo.txt
        # This file has the format of a standard RMG thermo library
        thermoData = thermo.data.ThermoDatabase()
        thermoData.load(os.path.join(path, 'species.txt'), '', os.path.join(path, 'thermo.txt'))
        # Populate the main primary thermo library with this thermo data
        # This will overwrite keys (but not values), so the order that the
        # seed mechanisms are loaded matters!
        for key, value in d.iteritems():
            thermo.data.thermoDatabase.primaryDatabase.dictionary[key] = value
        for key, value in thermoData.library.iteritems():
            thermo.data.thermoDatabase.primaryDatabase.library[key] = value

        # Create new species based on items in species.txt
        seedSpeciesDict = {}; seedSpeciesList = []
        for label, struct in d.iteritems():
            spec, isNew = species.makeNewSpecies(struct, label, reactive=True)
            seedSpeciesDict[label] = spec
            seedSpeciesList.append(spec)

        # Load the reactions from the file reaction.txt
        seedReactionList = []
        f = open(os.path.join(path, 'reactions.txt'), 'r')
        for line in f:
            line = data.removeCommentFromLine(line)
            line.strip()
            if len(line) > 0:
                items = line.split()
                if len(items) > 0:
                    rxn = items[0:-6]

                    # Extract reactants and products
                    if '<=>' in rxn: arrow = rxn.index('<=>')
                    elif '=>' in rxn: arrow = rxn.index('=>')
                    else: raise IOError('No arrow found in reaction equation from line {0}'.format(line))
                    reactants = rxn[0:arrow:2]
                    products = rxn[arrow+1::2]

                    # Remove third body 'M' if present
                    thirdBody = False
                    if 'M' in reactants and 'M' in products:
                        thirdBody = True
                        reactants.remove('M')
                        products.remove('M')

                    # Convert strings to species objects
                    reactants = [seedSpeciesDict[r] for r in reactants]
                    products = [seedSpeciesDict[r] for r in products]
                    reactants.sort()
                    products.sort()

                    # Process Arrhenius parameters
                    order = len(reactants)
                    if (thirdBody): order += 1
                    Aunits = 'cm^{0:d}/(mol^{1:d}*s)'.format(3*(order-1), order-1)
                    A = float(pq.Quantity(float(items[-6]), Aunits).simplified)
                    n = float(items[-5])			# dimensionless
                    Ea = float(pq.Quantity(float(items[-4]), 'cal/mol').simplified)
                    kin = [kinetics.model.Arrhenius(A=A, n=n, Ea=Ea)]

                    # Create reaction object and add to list
                    rxn = reaction.Reaction(id=0, reactants=reactants, products=products, family='seed', kinetics=kin, thirdBody=thirdBody)
                    rxn.reverse = reaction.Reaction(id=0, reactants=products, products=reactants, family='seed', kinetics=None, thirdBody=thirdBody)
                    rxn.reverse.reverse = rxn
                    reaction.processNewReaction(rxn)
                    seedReactionList.append(rxn)

        f.close()

        # Add species to core
        for spec in seedSpeciesList:
            self.addSpeciesToCore(spec)
        # Add reactions to core
        for rxn in seedReactionList:
            self.addReactionToCore(rxn)

    def markChemkinDuplicates(self):
        """
        Check that all reactions that will appear the chemkin output have been checked as duplicates.
        
        Call this if you've done something that may have introduced undetected duplicate reactions,
        like add a reaction library or seed mechanism.
        Anything added via the :meth:`expand` method should already be detected.
        """
        from rmgpy.chemkin import markDuplicateReactions
        
        rxnList = self.core.reactions + self.outputReactionList
        markDuplicateReactions(rxnList)
        
        
    def saveChemkinFile(self, path, verbose_path, dictionaryPath=None, transportPath=None, saveEdgeSpecies=False):
        """
        Save a Chemkin file for the current model as well as any desired output
        species and reactions to `path`.
        """
        from rmgpy.chemkin import saveChemkinFile, saveSpeciesDictionary, saveTransportFile
        speciesList = self.core.species + self.outputSpeciesList
        rxnList = self.core.reactions + self.outputReactionList
        saveChemkinFile(path, speciesList, rxnList, verbose = False, checkForDuplicates=False) # We should already have marked everything as duplicates by now        
        logging.info('Saving current model to verbose Chemkin file...')
        saveChemkinFile(verbose_path, speciesList, rxnList, verbose = True, checkForDuplicates=False)
        if dictionaryPath:
            saveSpeciesDictionary(dictionaryPath, speciesList)
        if transportPath:
            saveTransportFile(transportPath, speciesList)
            
        if saveEdgeSpecies == True:
            speciesList = self.edge.species + self.outputSpeciesList
            rxnList = self.edge.reactions + self.outputReactionList
            saveChemkinFile(path, speciesList, rxnList, verbose = False, checkForDuplicates=False)        
            logging.info('Saving current edge to verbose Chemkin file...')
            saveChemkinFile(verbose_path, speciesList, rxnList, verbose = True, checkForDuplicates=False)
            if dictionaryPath:
                saveSpeciesDictionary(dictionaryPath, speciesList)
                
    def failsSpeciesConstraints(self, species):
        """
        Pass in either a `Species` or `Molecule` object and checks whether it passes 
        the speciesConstraints set by the user.  If not, returns `True` for failing speciesConstraints.
        """
        explicitlyAllowedMolecules = self.speciesConstraints.get('explicitlyAllowedMolecules', [])
        maxCarbonAtoms = self.speciesConstraints.get('maximumCarbonAtoms', 1000000)
        maxHydrogenAtoms = self.speciesConstraints.get('maximumHydrogenAtoms', 1000000)
        maxOxygenAtoms = self.speciesConstraints.get('maximumOxygenAtoms', 1000000)
        maxNitrogenAtoms = self.speciesConstraints.get('maximumNitrogenAtoms', 1000000)
        maxSiliconAtoms = self.speciesConstraints.get('maximumSiliconAtoms', 1000000)
        maxSulfurAtoms = self.speciesConstraints.get('maximumSulfurAtoms', 1000000)
        maxHeavyAtoms = self.speciesConstraints.get('maximumHeavyAtoms', 1000000)
        maxRadicals = self.speciesConstraints.get('maximumRadicalElectrons', 1000000)
        
        if isinstance(species, rmgpy.species.Species):
            struct = species.molecule[0]
        else:
            # expects a molecule here
            struct = species
        for molecule in explicitlyAllowedMolecules:
            if struct.isIsomorphic(molecule):
                return False        
        H = struct.getNumAtoms('H')
        if struct.getNumAtoms('C') > maxCarbonAtoms:
            return True
        if H > maxHydrogenAtoms:
            return True
        if struct.getNumAtoms('O') > maxOxygenAtoms:
            return True
        if struct.getNumAtoms('N') > maxNitrogenAtoms:
            return True
        if struct.getNumAtoms('Si') > maxSiliconAtoms:
            return True
        if struct.getNumAtoms('S') > maxSulfurAtoms:
            return True
        if len(struct.atoms) - H > maxHeavyAtoms:
            return True
        if (struct.getNumberOfRadicalElectrons() > maxRadicals):
            return True
        return False