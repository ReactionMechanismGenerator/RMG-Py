
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>rmgpy.molecule.Group &#8212; RMG-Py 3.3.0 Documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="rmgpy.molecule.resonance" href="resonance.html" />
    <link rel="prev" title="rmgpy.molecule.GroupBond" href="groupbond.html" />
<script type="text/x-mathjax-config">
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
    ce: ["Extension","mhchem"],
  });
});
</script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="resonance.html" title="rmgpy.molecule.resonance"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="groupbond.html" title="rmgpy.molecule.GroupBond"
             accesskey="P">previous</a> |</li>
  <li><a href="https://rmg.mit.edu/">RMG</a> &raquo;</li>
  <li><a href="../../index.html">3.3.0 Documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" >RMG API Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">Molecular representations (<code class="xref py py-mod docutils literal notranslate"><span class="pre">rmgpy.molecule</span></code>)</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">rmgpy.molecule.Group</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="rmgpy-molecule-group">
<span id="id1"></span><h1>rmgpy.molecule.Group<a class="headerlink" href="#rmgpy-molecule-group" title="Permalink to this heading">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="rmgpy.molecule.Group">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">rmgpy.molecule.</span></span><span class="sig-name descname"><span class="pre">Group</span></span><a class="headerlink" href="#rmgpy.molecule.Group" title="Permalink to this definition">¶</a></dt>
<dd><p>A representation of a molecular substructure group using a graph data
type, extending the <code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code> class. The attributes are:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Attribute</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>atoms</cite></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">list</span></code></p></td>
<td><p>Aliases for the <cite>vertices</cite> storing <a class="reference internal" href="groupatom.html#rmgpy.molecule.GroupAtom" title="rmgpy.molecule.GroupAtom"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupAtom</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><cite>multiplicity</cite></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">list</span></code></p></td>
<td><p>Range of multiplicities accepted for the group</p></td>
</tr>
<tr class="row-even"><td><p><cite>props</cite></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">dict</span></code></p></td>
<td><p>Dictionary of arbitrary properties/flags classifying state of Group object</p></td>
</tr>
<tr class="row-odd"><td><p><cite>metal</cite></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">list</span></code></p></td>
<td><p>List of metals accepted for the group</p></td>
</tr>
<tr class="row-even"><td><p><cite>facet</cite></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">list</span></code></p></td>
<td><p>List of facets accepted for the group</p></td>
</tr>
</tbody>
</table>
<p>Corresponding alias methods to Molecule have also been provided.</p>
<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.add_atom">
<span class="sig-name descname"><span class="pre">add_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atom</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.add_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an <cite>atom</cite> to the graph. The atom is initialized with no bonds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.add_bond">
<span class="sig-name descname"><span class="pre">add_bond</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bond</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.add_bond" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a <cite>bond</cite> to the graph as an edge connecting the two atoms <cite>atom1</cite>
and <cite>atom2</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.add_edge">
<span class="sig-name descname"><span class="pre">add_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.add_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an <cite>edge</cite> to the graph. The two vertices in the edge must already
exist in the graph, or a <code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code> is raised.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.add_explicit_ligands">
<span class="sig-name descname"><span class="pre">add_explicit_ligands</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.add_explicit_ligands" title="Permalink to this definition">¶</a></dt>
<dd><p>This function O2d/S2d ligand to CO or CS atomtypes if they are not already there.</p>
<p>Returns a ‘True’ if the group was modified otherwise returns ‘False’</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.add_implicit_atoms_from_atomtype">
<span class="sig-name descname"><span class="pre">add_implicit_atoms_from_atomtype</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.add_implicit_atoms_from_atomtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns: a modified group with implicit atoms added
Add implicit double/triple bonded atoms O, S or R, for which we will use a C</p>
<p>Not designed to work with wildcards</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.add_implicit_benzene">
<span class="sig-name descname"><span class="pre">add_implicit_benzene</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.add_implicit_benzene" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns: A modified group with any implicit benzene rings added</p>
<p>This method currently does not if there are wildcards in atomtypes or bond orders
The current algorithm also requires that all Cb and Cbf are atomtyped</p>
<p>There are other cases where the algorithm doesn’t work. For example whenever there
are many dangling Cb or Cbf atoms not in a ring, it is likely fail. In the database test
(the only use thus far), we will require that any group with more than 3 Cbfs have
complete rings. This is much stricter than this method can handle, but right now
this method cannot handle very general cases, so it is better to be conservative.</p>
<p>Note that it also works on other aromatic atomtypes like N5bd etc.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.add_vertex">
<span class="sig-name descname"><span class="pre">add_vertex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.add_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a <cite>vertex</cite> to the graph. The vertex is initialized with no edges.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.atoms">
<span class="sig-name descname"><span class="pre">atoms</span></span><a class="headerlink" href="#rmgpy.molecule.Group.atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>List of atoms contained in the current molecule.</p>
<p>Renames the inherited vertices attribute of <code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.classify_benzene_carbons">
<span class="sig-name descname"><span class="pre">classify_benzene_carbons</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">partners</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.classify_benzene_carbons" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> – :class:Group with atoms to classify</p></li>
<li><p><strong>partners</strong> – dictionary of partnered up atoms, which must be a cbf atom</p></li>
</ul>
</dd>
</dl>
<p>Some non-carbon ‘benzene’ type atoms (eg. N3b) are included and classified.</p>
<p>Returns: tuple with lists of each atom classification:
cb_atom_list, cbf_atom_list, cbf_atom_list1, cbf_atom_list2, connected_cbfs</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.clear_labeled_atoms">
<span class="sig-name descname"><span class="pre">clear_labeled_atoms</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.clear_labeled_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the labels from all atoms in the molecular group.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.clear_reg_dims">
<span class="sig-name descname"><span class="pre">clear_reg_dims</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.clear_reg_dims" title="Permalink to this definition">¶</a></dt>
<dd><p>clear regularization dimensions</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.contains_labeled_atom">
<span class="sig-name descname"><span class="pre">contains_labeled_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.contains_labeled_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the group contains an atom with the label
<cite>label</cite> and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.contains_surface_site">
<span class="sig-name descname"><span class="pre">contains_surface_site</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.contains_surface_site" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> iff the group contains an ‘X’ surface site.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the current graph. If <cite>deep</cite> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, a deep copy
is made: copies of the vertices and edges are used in the new graph.
If <cite>deep</cite> is <code class="docutils literal notranslate"><span class="pre">False</span></code> or not specified, a shallow copy is made: the
original vertices and edges are used in the new graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.copy_and_map">
<span class="sig-name descname"><span class="pre">copy_and_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.copy_and_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a deep copy of the current graph, and return the dict
‘mapping’. Method was modified from Graph.copy() method</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.create_and_connect_atom">
<span class="sig-name descname"><span class="pre">create_and_connect_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atomtypes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connecting_atom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bond_orders</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.create_and_connect_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>This method creates an non-radical, uncharged, :class:GroupAtom with specified list of atomtypes and
connects it to one atom of the group, ‘connecting_atom’. This is useful for making sample atoms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atomtypes</strong> – list of atomtype labels (strs)</p></li>
<li><p><strong>connecting_atom</strong> – :class:GroupAtom that is connected to the new benzene atom</p></li>
<li><p><strong>bond_orders</strong> – list of bond Orders connecting new_atom and connecting_atom</p></li>
</ul>
</dd>
</dl>
<p>Returns: the newly created atom</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.draw">
<span class="sig-name descname"><span class="pre">draw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_format</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Use pydot to draw a basic graph of the group.</p>
<p>Use format to specify the desired output file_format, eg. ‘png’, ‘svg’, ‘ps’, ‘pdf’, ‘plain’, etc.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.find_isomorphism">
<span class="sig-name descname"><span class="pre">find_isomorphism</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.find_isomorphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <cite>other</cite> is isomorphic and <code class="docutils literal notranslate"><span class="pre">False</span></code>
otherwise, and the matching mapping. The <cite>initial_map</cite> attribute can be
used to specify a required mapping from <cite>self</cite> to <cite>other</cite> (i.e. the
atoms of <cite>self</cite> are the keys, while the atoms of <cite>other</cite> are the
values). The returned mapping also uses the atoms of <cite>self</cite> for the keys
and the atoms of <cite>other</cite> for the values. The <cite>other</cite> parameter must
be a <a class="reference internal" href="#rmgpy.molecule.Group" title="rmgpy.molecule.Group"><code class="xref py py-class docutils literal notranslate"><span class="pre">Group</span></code></a> object, or a <code class="xref py py-class docutils literal notranslate"><span class="pre">TypeError</span></code> is raised.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.find_subgraph_isomorphisms">
<span class="sig-name descname"><span class="pre">find_subgraph_isomorphisms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.find_subgraph_isomorphisms" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <cite>other</cite> is subgraph isomorphic and <code class="docutils literal notranslate"><span class="pre">False</span></code>
otherwise. In other words, return <code class="docutils literal notranslate"><span class="pre">True</span></code> is self is more specific than other.
Also returns the lists all of valid mappings. The
<cite>initial_map</cite> attribute can be used to specify a required mapping from
<cite>self</cite> to <cite>other</cite> (i.e. the atoms of <cite>self</cite> are the keys, while the
atoms of <cite>other</cite> are the values). The returned mappings also use the
atoms of <cite>self</cite> for the keys and the atoms of <cite>other</cite> for the values.
The <cite>other</cite> parameter must be a <a class="reference internal" href="#rmgpy.molecule.Group" title="rmgpy.molecule.Group"><code class="xref py py-class docutils literal notranslate"><span class="pre">Group</span></code></a> object, or a
<code class="xref py py-class docutils literal notranslate"><span class="pre">TypeError</span></code> is raised.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.from_adjacency_list">
<span class="sig-name descname"><span class="pre">from_adjacency_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adjlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_consistency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.from_adjacency_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a string adjacency list <cite>adjlist</cite> to a molecular structure.
Skips the first line (assuming it’s a label) unless <cite>withLabel</cite> is
<code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_all_cycles">
<span class="sig-name descname"><span class="pre">get_all_cycles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">starting_vertex</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_all_cycles" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a starting vertex, returns a list of all the cycles containing
that vertex.</p>
<p>This function returns a duplicate of each cycle because [0,1,2,3]
is counted as separate from [0,3,2,1]</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_all_cycles_of_size">
<span class="sig-name descname"><span class="pre">get_all_cycles_of_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_all_cycles_of_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the all non-duplicate rings with length ‘size’. The
algorithm implements was adapted from a description by Fan, Panaye,
Doucet, and Barbu (doi: 10.1021/ci00015a002)</p>
<p>B. T. Fan, A. Panaye, J. P. Doucet, and A. Barbu. “Ring Perception: A
New Algorithm for Directly Finding the Smallest Set of Smallest Rings
from a Connection Table.” <em>J. Chem. Inf. Comput. Sci.</em> <strong>33</strong>,
p. 657-662 (1993).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_all_cyclic_vertices">
<span class="sig-name descname"><span class="pre">get_all_cyclic_vertices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_all_cyclic_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all vertices belonging to one or more cycles.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_all_edges">
<span class="sig-name descname"><span class="pre">get_all_edges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_all_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all edges in the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_all_labeled_atoms">
<span class="sig-name descname"><span class="pre">get_all_labeled_atoms</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_all_labeled_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the labeled atoms as a <code class="docutils literal notranslate"><span class="pre">dict</span></code> with the keys being the labels
and the values the atoms themselves. If two or more atoms have the
same label, the value is converted to a list of these atoms.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_all_polycyclic_vertices">
<span class="sig-name descname"><span class="pre">get_all_polycyclic_vertices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_all_polycyclic_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all vertices belonging to two or more cycles, fused or spirocyclic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_all_simple_cycles_of_size">
<span class="sig-name descname"><span class="pre">get_all_simple_cycles_of_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_all_simple_cycles_of_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of all non-duplicate monocyclic rings with length ‘size’.</p>
<p>Naive approach by eliminating polycyclic rings that are returned by
<code class="docutils literal notranslate"><span class="pre">getAllCyclicsOfSize</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_bond">
<span class="sig-name descname"><span class="pre">get_bond</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atom1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_bond" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the bond connecting atoms <cite>atom1</cite> and <cite>atom2</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_bonds">
<span class="sig-name descname"><span class="pre">get_bonds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atom</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_bonds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the bonds involving the specified <cite>atom</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_disparate_cycles">
<span class="sig-name descname"><span class="pre">get_disparate_cycles</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_disparate_cycles" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all disjoint monocyclic and polycyclic cycle clusters in the molecule.
Takes the RC and recursively merges all cycles which share vertices.</p>
<p>Returns: monocyclic_cycles, polycyclic_cycles</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_edge">
<span class="sig-name descname"><span class="pre">get_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the edge connecting vertices <cite>vertex1</cite> and <cite>vertex2</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_edges">
<span class="sig-name descname"><span class="pre">get_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary of the edges involving the specified <cite>vertex</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_edges_in_cycle">
<span class="sig-name descname"><span class="pre">get_edges_in_cycle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_edges_in_cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given list of atoms comprising a ring, return the set of bonds
connecting them, in order around the ring.</p>
<p>If <cite>sort=True</cite>, then sort the vertices to match their connectivity.
Otherwise, assumes that they are already sorted, which is true for
cycles returned by get_relevant_cycles or get_smallest_set_of_smallest_rings.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_element_count">
<span class="sig-name descname"><span class="pre">get_element_count</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_element_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the element count for the molecule as a dictionary.
Wildcards are not counted as any particular element.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_extensions">
<span class="sig-name descname"><span class="pre">get_extensions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_bonds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_un</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atm_ind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atm_ind2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_splits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_extensions" title="Permalink to this definition">¶</a></dt>
<dd><p>generate all allowed group extensions and their complements
note all atomtypes except for elements and r/r!H’s must be removed</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_labeled_atoms">
<span class="sig-name descname"><span class="pre">get_labeled_atoms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_labeled_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the atom in the group that is labeled with the given <cite>label</cite>.
Raises <code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code> if no atom in the group has that label.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_largest_ring">
<span class="sig-name descname"><span class="pre">get_largest_ring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_largest_ring" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the largest ring containing vertex. This is typically
useful for finding the longest path in a polycyclic ring, since
the polycyclic rings returned from get_polycycles are not necessarily
in order in the ring structure.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_max_cycle_overlap">
<span class="sig-name descname"><span class="pre">get_max_cycle_overlap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_max_cycle_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum number of vertices that are shared between
any two cycles in the graph. For example, if there are only
disparate monocycles or no cycles, the maximum overlap is zero;
if there are “spiro” cycles, it is one; if there are “fused”
cycles, it is two; and if there are “bridged” cycles, it is
three.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_monocycles">
<span class="sig-name descname"><span class="pre">get_monocycles</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_monocycles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of cycles that are monocyclic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_net_charge">
<span class="sig-name descname"><span class="pre">get_net_charge</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_net_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate through the atoms in the group and calculate the net charge</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_polycycles">
<span class="sig-name descname"><span class="pre">get_polycycles</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_polycycles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of cycles that are polycyclic.
In other words, merge the cycles which are fused or spirocyclic into
a single polycyclic cycle, and return only those cycles.
Cycles which are not polycyclic are not returned.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_relevant_cycles">
<span class="sig-name descname"><span class="pre">get_relevant_cycles</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_relevant_cycles" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the set of relevant cycles as a list of lists.
Uses RingDecomposerLib for ring perception.</p>
<p>Kolodzik, A.; Urbaczek, S.; Rarey, M.
Unique Ring Families: A Chemically Meaningful Description
of Molecular Ring Topologies.
J. Chem. Inf. Model., 2012, 52 (8), pp 2013-2021</p>
<p>Flachsenberg, F.; Andresen, N.; Rarey, M.
RingDecomposerLib: An Open-Source Implementation of
Unique Ring Families and Other Cycle Bases.
J. Chem. Inf. Model., 2017, 57 (2), pp 122-126</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_smallest_set_of_smallest_rings">
<span class="sig-name descname"><span class="pre">get_smallest_set_of_smallest_rings</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_smallest_set_of_smallest_rings" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the smallest set of smallest rings as a list of lists.
Uses RingDecomposerLib for ring perception.</p>
<p>Kolodzik, A.; Urbaczek, S.; Rarey, M.
Unique Ring Families: A Chemically Meaningful Description
of Molecular Ring Topologies.
J. Chem. Inf. Model., 2012, 52 (8), pp 2013-2021</p>
<p>Flachsenberg, F.; Andresen, N.; Rarey, M.
RingDecomposerLib: An Open-Source Implementation of
Unique Ring Families and Other Cycle Bases.
J. Chem. Inf. Model., 2017, 57 (2), pp 122-126</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.get_surface_sites">
<span class="sig-name descname"><span class="pre">get_surface_sites</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.get_surface_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of surface site GroupAtoms in the group.
:returns: A list containing the surface site GroupAtoms in the molecule
:rtype: List(GroupAtom)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.has_atom">
<span class="sig-name descname"><span class="pre">has_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atom</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.has_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <cite>atom</cite> is an atom in the graph, or <code class="docutils literal notranslate"><span class="pre">False</span></code> if
not.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.has_bond">
<span class="sig-name descname"><span class="pre">has_bond</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atom1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.has_bond" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if atoms <cite>atom1</cite> and <cite>atom2</cite> are connected
by an bond, or <code class="docutils literal notranslate"><span class="pre">False</span></code> if not.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.has_edge">
<span class="sig-name descname"><span class="pre">has_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.has_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if vertices <cite>vertex1</cite> and <cite>vertex2</cite> are connected
by an edge, or <code class="docutils literal notranslate"><span class="pre">False</span></code> if not.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.has_vertex">
<span class="sig-name descname"><span class="pre">has_vertex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.has_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <cite>vertex</cite> is a vertex in the graph, or <code class="docutils literal notranslate"><span class="pre">False</span></code> if
not.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.has_wildcards">
<span class="sig-name descname"><span class="pre">has_wildcards</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.has_wildcards" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is a Group level wildcards checker.</p>
<p>Returns a ‘True’ if any of the atoms in this group has wildcards.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.is_aromatic_ring">
<span class="sig-name descname"><span class="pre">is_aromatic_ring</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.is_aromatic_ring" title="Permalink to this definition">¶</a></dt>
<dd><p>This method returns a boolean telling if the group has a 5 or 6 cyclic with
benzene bonds exclusively</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.is_benzene_explicit">
<span class="sig-name descname"><span class="pre">is_benzene_explicit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.is_benzene_explicit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns: ‘True’ if all Cb, Cbf (and other ‘b’ atoms)
are in completely explicitly stated benzene rings.</p>
<p>Otherwise return ‘False’</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.is_cyclic">
<span class="sig-name descname"><span class="pre">is_cyclic</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.is_cyclic" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if one or more cycles are present in the graph or
<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.is_edge_in_cycle">
<span class="sig-name descname"><span class="pre">is_edge_in_cycle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.is_edge_in_cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="xref py py-data docutils literal notranslate"><span class="pre">True</span></code> if the edge between vertices <cite>vertex1</cite> and <cite>vertex2</cite>
is in one or more cycles in the graph, or <code class="xref py py-data docutils literal notranslate"><span class="pre">False</span></code> if not.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.is_electron">
<span class="sig-name descname"><span class="pre">is_electron</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.is_electron" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> iff the group is an electron</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.is_identical">
<span class="sig-name descname"><span class="pre">is_identical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.is_identical" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <cite>other</cite> is identical and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.
The function <cite>is_isomorphic</cite> respects wildcards, while this function
does not, make it more useful for checking groups to groups (as
opposed to molecules to groups)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.is_isomorphic">
<span class="sig-name descname"><span class="pre">is_isomorphic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generate_initial_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.is_isomorphic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if two graphs are isomorphic and <code class="docutils literal notranslate"><span class="pre">False</span></code>
otherwise. The <cite>initial_map</cite> attribute can be used to specify a required
mapping from <cite>self</cite> to <cite>other</cite> (i.e. the atoms of <cite>self</cite> are the keys,
while the atoms of <cite>other</cite> are the values). The <cite>other</cite> parameter must
be a <a class="reference internal" href="#rmgpy.molecule.Group" title="rmgpy.molecule.Group"><code class="xref py py-class docutils literal notranslate"><span class="pre">Group</span></code></a> object, or a <code class="xref py py-class docutils literal notranslate"><span class="pre">TypeError</span></code> is raised.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.is_mapping_valid">
<span class="sig-name descname"><span class="pre">is_mapping_valid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equivalent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.is_mapping_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that a proposed <cite>mapping</cite> of vertices from <cite>self</cite> to <cite>other</cite>
is valid by checking that the vertices and edges involved in the
mapping are mutually equivalent.  If equivalent is <code class="docutils literal notranslate"><span class="pre">True</span></code> it checks
if atoms and edges are equivalent, if <code class="docutils literal notranslate"><span class="pre">False</span></code> it checks if they
are specific cases of each other. If strict is <code class="docutils literal notranslate"><span class="pre">True</span></code>, electrons
and bond orders are considered, and ignored if <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.is_proton">
<span class="sig-name descname"><span class="pre">is_proton</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.is_proton" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> iff the group is a proton</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.is_subgraph_isomorphic">
<span class="sig-name descname"><span class="pre">is_subgraph_isomorphic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generate_initial_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.is_subgraph_isomorphic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <cite>other</cite> is subgraph isomorphic and <code class="docutils literal notranslate"><span class="pre">False</span></code>
otherwise. In other words, return <code class="docutils literal notranslate"><span class="pre">True</span></code> if self is more specific than other.
The <cite>initial_map</cite> attribute can be used to specify a required
mapping from <cite>self</cite> to <cite>other</cite> (i.e. the atoms of <cite>self</cite> are the keys,
while the atoms of <cite>other</cite> are the values). The <cite>other</cite> parameter must
be a <a class="reference internal" href="#rmgpy.molecule.Group" title="rmgpy.molecule.Group"><code class="xref py py-class docutils literal notranslate"><span class="pre">Group</span></code></a> object, or a <code class="xref py py-class docutils literal notranslate"><span class="pre">TypeError</span></code> is raised.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.is_surface_site">
<span class="sig-name descname"><span class="pre">is_surface_site</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.is_surface_site" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> iff the group is nothing but a surface site ‘X’.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.is_vertex_in_cycle">
<span class="sig-name descname"><span class="pre">is_vertex_in_cycle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.is_vertex_in_cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the given <cite>vertex</cite> is contained in one or more
cycles in the graph, or <code class="docutils literal notranslate"><span class="pre">False</span></code> if not.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.make_sample_molecule">
<span class="sig-name descname"><span class="pre">make_sample_molecule</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.make_sample_molecule" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns: A sample class :Molecule: from the group</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.merge">
<span class="sig-name descname"><span class="pre">merge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge two groups so as to store them in a single
<a class="reference internal" href="#rmgpy.molecule.Group" title="rmgpy.molecule.Group"><code class="xref py py-class docutils literal notranslate"><span class="pre">Group</span></code></a> object. The merged <a class="reference internal" href="#rmgpy.molecule.Group" title="rmgpy.molecule.Group"><code class="xref py py-class docutils literal notranslate"><span class="pre">Group</span></code></a>
object is returned.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.merge_groups">
<span class="sig-name descname"><span class="pre">merge_groups</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_identical_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.merge_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>This function takes <cite>other</cite> :class:Group object and returns a merged :class:Group object based
on overlapping labeled atoms between self and other</p>
<p>Currently assumes <cite>other</cite> can be merged at the closest labelled atom
if keep_identical_labels=True merge_groups will not try to merge atoms with the same labels</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.pick_wildcards">
<span class="sig-name descname"><span class="pre">pick_wildcards</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.pick_wildcards" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns: the :class:Group object without wildcards in either atomtype or bonding</p>
<p>This function will naively pick the first atomtype for each atom, but will try
to pick bond orders that make sense given the selected atomtypes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.remove_atom">
<span class="sig-name descname"><span class="pre">remove_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atom</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.remove_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove <cite>atom</cite> and all bonds associated with it from the graph. Does
not remove atoms that no longer have any bonds as a result of this
removal.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.remove_bond">
<span class="sig-name descname"><span class="pre">remove_bond</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bond</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.remove_bond" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the bond between atoms <cite>atom1</cite> and <cite>atom2</cite> from the graph.
Does not remove atoms that no longer have any bonds as a result of
this removal.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.remove_edge">
<span class="sig-name descname"><span class="pre">remove_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.remove_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the specified <cite>edge</cite> from the graph.
Does not remove vertices that no longer have any edges as a result of
this removal.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.remove_van_der_waals_bonds">
<span class="sig-name descname"><span class="pre">remove_van_der_waals_bonds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.remove_van_der_waals_bonds" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all bonds that are definitely only van der Waals bonds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.remove_vertex">
<span class="sig-name descname"><span class="pre">remove_vertex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.remove_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove <cite>vertex</cite> and all edges associated with it from the graph. Does
not remove vertices that no longer have any edges as a result of this
removal.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.reset_connectivity_values">
<span class="sig-name descname"><span class="pre">reset_connectivity_values</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.reset_connectivity_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset any cached connectivity information. Call this method when you
have modified the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.reset_ring_membership">
<span class="sig-name descname"><span class="pre">reset_ring_membership</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.reset_ring_membership" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets ring membership information in the GroupAtom.props attribute.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.restore_vertex_order">
<span class="sig-name descname"><span class="pre">restore_vertex_order</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.restore_vertex_order" title="Permalink to this definition">¶</a></dt>
<dd><p>reorder the vertices to what they were before sorting
if you saved the order</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.sort_atoms">
<span class="sig-name descname"><span class="pre">sort_atoms</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.sort_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort the atoms in the graph. This can make certain operations, e.g.
the isomorphism functions, much more efficient.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.sort_by_connectivity">
<span class="sig-name descname"><span class="pre">sort_by_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atom_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.sort_by_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atom_list</strong> – input list of atoms</p>
</dd>
</dl>
<p>Returns: a sorted list of atoms where each atom is connected to a previous
atom in the list if possible</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.sort_cyclic_vertices">
<span class="sig-name descname"><span class="pre">sort_cyclic_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.sort_cyclic_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of vertices comprising a cycle, sort them such that adjacent
entries in the list are connected to each other.
Warning: Assumes that the cycle is elementary, ie. no bridges.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.sort_vertices">
<span class="sig-name descname"><span class="pre">sort_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">save_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.sort_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort the vertices in the graph. This can make certain operations, e.g.
the isomorphism functions, much more efficient.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.specify_atom_extensions">
<span class="sig-name descname"><span class="pre">specify_atom_extensions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.specify_atom_extensions" title="Permalink to this definition">¶</a></dt>
<dd><p>generates extensions for specification of the type of atom defined by a given atomtype
or set of atomtypes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.specify_bond_extensions">
<span class="sig-name descname"><span class="pre">specify_bond_extensions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_bonds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.specify_bond_extensions" title="Permalink to this definition">¶</a></dt>
<dd><p>generates extensions for the specification of bond order for a given bond</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.specify_external_new_bond_extensions">
<span class="sig-name descname"><span class="pre">specify_external_new_bond_extensions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_bonds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.specify_external_new_bond_extensions" title="Permalink to this definition">¶</a></dt>
<dd><p>generates extensions for the creation of a bond (of undefined order) between
an atom and a new atom that is not H</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.specify_internal_new_bond_extensions">
<span class="sig-name descname"><span class="pre">specify_internal_new_bond_extensions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_splits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_bonds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.specify_internal_new_bond_extensions" title="Permalink to this definition">¶</a></dt>
<dd><p>generates extensions for creation of a bond (of undefined order)
between two atoms indexed i,j that already exist in the group and are unbonded</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.specify_ring_extensions">
<span class="sig-name descname"><span class="pre">specify_ring_extensions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.specify_ring_extensions" title="Permalink to this definition">¶</a></dt>
<dd><p>generates extensions for specifying if an atom is in a ring</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.specify_unpaired_extensions">
<span class="sig-name descname"><span class="pre">specify_unpaired_extensions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_un</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.specify_unpaired_extensions" title="Permalink to this definition">¶</a></dt>
<dd><p>generates extensions for specification of the number of electrons on a given atom</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.split">
<span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a single <a class="reference internal" href="#rmgpy.molecule.Group" title="rmgpy.molecule.Group"><code class="xref py py-class docutils literal notranslate"><span class="pre">Group</span></code></a> object containing two or more
unconnected groups into separate class:<cite>Group</cite> objects.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.standardize_atomtype">
<span class="sig-name descname"><span class="pre">standardize_atomtype</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.standardize_atomtype" title="Permalink to this definition">¶</a></dt>
<dd><p>This function changes the atomtypes in a group if the atom must
be a specific atomtype based on its bonds and valency.</p>
<p>Currently only standardizes oxygen, carbon and sulfur ATOMTYPES</p>
<p>We also only check when there is exactly one atomtype,
one bondType, one radical setting.
For any group where there are wildcards or multiple attributes,
we cannot apply this check.</p>
<p>In the case where the atomtype is ambiguous based on bonds
and valency, this function will not change the type.</p>
<p>Returns a ‘True’ if the group was modified otherwise returns ‘False’</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.standardize_group">
<span class="sig-name descname"><span class="pre">standardize_group</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.standardize_group" title="Permalink to this definition">¶</a></dt>
<dd><p>This function modifies groups to make them have a standard AdjList form.</p>
<p>Currently it makes atomtypes as specific as possible and makes CO/CS atomtypes
have explicit O2d/S2d ligands. Other functions can be added as necessary</p>
<p>Returns a ‘True’ if the group was modified otherwise returns ‘False’</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.to_adjacency_list">
<span class="sig-name descname"><span class="pre">to_adjacency_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.to_adjacency_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the molecular structure to a string adjacency list.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.update_charge">
<span class="sig-name descname"><span class="pre">update_charge</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.update_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the partial charge according to the valence electron, total bond order, lone pairs
and radical electrons. This method is used for products of specific families with recipes that modify charges.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.update_connectivity_values">
<span class="sig-name descname"><span class="pre">update_connectivity_values</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.update_connectivity_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the connectivity values for each vertex in the graph. These are
used to accelerate the isomorphism checking.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rmgpy.molecule.Group.update_fingerprint">
<span class="sig-name descname"><span class="pre">update_fingerprint</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rmgpy.molecule.Group.update_fingerprint" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the molecular fingerprint used to accelerate the subgraph
isomorphism checks.</p>
</dd></dl>

</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
  <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
    <div class="sphinxsidebarwrapper">
        <div class="sidebarlogo"><a href="../../index.html">
            <img src="../../_static/rmg-logo-small.png" alt="RMG" />
        </a></div>
      <div id="sidebar">
        <div id="rmgsidebar">
          <a href="https://rmg.mit.edu">
            <div class="menuitem">
              <img src="../../_static/rmg-icon.png" class="icon" width="100%"/>
              <div class="menutext menutitle">RMG Website</div>
              <div class="menutext menudesc">Interactive website for RMG-Py</div>
            </div>
          </a>
          <a href="https://github.com/ReactionMechanismGenerator/RMG-Py">
            <div class="menuitem">
              <img src="../../_static/github-icon.png" class="icon" width="100%"/>
              <div class="menutext menutitle">RMG GitHub</div>
              <div class="menutext menudesc">View source and post issues</div>
            </div>
          </a>
        </div>
        <div class="menuitem">
  <div>
    <h3><a href="../../contents.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">rmgpy.molecule.Group</a><ul>
<li><a class="reference internal" href="#rmgpy.molecule.Group"><code class="docutils literal notranslate"><span class="pre">Group</span></code></a><ul>
<li><a class="reference internal" href="#rmgpy.molecule.Group.add_atom"><code class="docutils literal notranslate"><span class="pre">Group.add_atom()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.add_bond"><code class="docutils literal notranslate"><span class="pre">Group.add_bond()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.add_edge"><code class="docutils literal notranslate"><span class="pre">Group.add_edge()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.add_explicit_ligands"><code class="docutils literal notranslate"><span class="pre">Group.add_explicit_ligands()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.add_implicit_atoms_from_atomtype"><code class="docutils literal notranslate"><span class="pre">Group.add_implicit_atoms_from_atomtype()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.add_implicit_benzene"><code class="docutils literal notranslate"><span class="pre">Group.add_implicit_benzene()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.add_vertex"><code class="docutils literal notranslate"><span class="pre">Group.add_vertex()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.atoms"><code class="docutils literal notranslate"><span class="pre">Group.atoms</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.classify_benzene_carbons"><code class="docutils literal notranslate"><span class="pre">Group.classify_benzene_carbons()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.clear_labeled_atoms"><code class="docutils literal notranslate"><span class="pre">Group.clear_labeled_atoms()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.clear_reg_dims"><code class="docutils literal notranslate"><span class="pre">Group.clear_reg_dims()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.contains_labeled_atom"><code class="docutils literal notranslate"><span class="pre">Group.contains_labeled_atom()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.contains_surface_site"><code class="docutils literal notranslate"><span class="pre">Group.contains_surface_site()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.copy"><code class="docutils literal notranslate"><span class="pre">Group.copy()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.copy_and_map"><code class="docutils literal notranslate"><span class="pre">Group.copy_and_map()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.create_and_connect_atom"><code class="docutils literal notranslate"><span class="pre">Group.create_and_connect_atom()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.draw"><code class="docutils literal notranslate"><span class="pre">Group.draw()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.find_isomorphism"><code class="docutils literal notranslate"><span class="pre">Group.find_isomorphism()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.find_subgraph_isomorphisms"><code class="docutils literal notranslate"><span class="pre">Group.find_subgraph_isomorphisms()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.from_adjacency_list"><code class="docutils literal notranslate"><span class="pre">Group.from_adjacency_list()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_all_cycles"><code class="docutils literal notranslate"><span class="pre">Group.get_all_cycles()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_all_cycles_of_size"><code class="docutils literal notranslate"><span class="pre">Group.get_all_cycles_of_size()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_all_cyclic_vertices"><code class="docutils literal notranslate"><span class="pre">Group.get_all_cyclic_vertices()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_all_edges"><code class="docutils literal notranslate"><span class="pre">Group.get_all_edges()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_all_labeled_atoms"><code class="docutils literal notranslate"><span class="pre">Group.get_all_labeled_atoms()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_all_polycyclic_vertices"><code class="docutils literal notranslate"><span class="pre">Group.get_all_polycyclic_vertices()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_all_simple_cycles_of_size"><code class="docutils literal notranslate"><span class="pre">Group.get_all_simple_cycles_of_size()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_bond"><code class="docutils literal notranslate"><span class="pre">Group.get_bond()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_bonds"><code class="docutils literal notranslate"><span class="pre">Group.get_bonds()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_disparate_cycles"><code class="docutils literal notranslate"><span class="pre">Group.get_disparate_cycles()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_edge"><code class="docutils literal notranslate"><span class="pre">Group.get_edge()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_edges"><code class="docutils literal notranslate"><span class="pre">Group.get_edges()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_edges_in_cycle"><code class="docutils literal notranslate"><span class="pre">Group.get_edges_in_cycle()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_element_count"><code class="docutils literal notranslate"><span class="pre">Group.get_element_count()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_extensions"><code class="docutils literal notranslate"><span class="pre">Group.get_extensions()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_labeled_atoms"><code class="docutils literal notranslate"><span class="pre">Group.get_labeled_atoms()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_largest_ring"><code class="docutils literal notranslate"><span class="pre">Group.get_largest_ring()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_max_cycle_overlap"><code class="docutils literal notranslate"><span class="pre">Group.get_max_cycle_overlap()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_monocycles"><code class="docutils literal notranslate"><span class="pre">Group.get_monocycles()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_net_charge"><code class="docutils literal notranslate"><span class="pre">Group.get_net_charge()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_polycycles"><code class="docutils literal notranslate"><span class="pre">Group.get_polycycles()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_relevant_cycles"><code class="docutils literal notranslate"><span class="pre">Group.get_relevant_cycles()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_smallest_set_of_smallest_rings"><code class="docutils literal notranslate"><span class="pre">Group.get_smallest_set_of_smallest_rings()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.get_surface_sites"><code class="docutils literal notranslate"><span class="pre">Group.get_surface_sites()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.has_atom"><code class="docutils literal notranslate"><span class="pre">Group.has_atom()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.has_bond"><code class="docutils literal notranslate"><span class="pre">Group.has_bond()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.has_edge"><code class="docutils literal notranslate"><span class="pre">Group.has_edge()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.has_vertex"><code class="docutils literal notranslate"><span class="pre">Group.has_vertex()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.has_wildcards"><code class="docutils literal notranslate"><span class="pre">Group.has_wildcards()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.is_aromatic_ring"><code class="docutils literal notranslate"><span class="pre">Group.is_aromatic_ring()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.is_benzene_explicit"><code class="docutils literal notranslate"><span class="pre">Group.is_benzene_explicit()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.is_cyclic"><code class="docutils literal notranslate"><span class="pre">Group.is_cyclic()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.is_edge_in_cycle"><code class="docutils literal notranslate"><span class="pre">Group.is_edge_in_cycle()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.is_electron"><code class="docutils literal notranslate"><span class="pre">Group.is_electron()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.is_identical"><code class="docutils literal notranslate"><span class="pre">Group.is_identical()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.is_isomorphic"><code class="docutils literal notranslate"><span class="pre">Group.is_isomorphic()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.is_mapping_valid"><code class="docutils literal notranslate"><span class="pre">Group.is_mapping_valid()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.is_proton"><code class="docutils literal notranslate"><span class="pre">Group.is_proton()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.is_subgraph_isomorphic"><code class="docutils literal notranslate"><span class="pre">Group.is_subgraph_isomorphic()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.is_surface_site"><code class="docutils literal notranslate"><span class="pre">Group.is_surface_site()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.is_vertex_in_cycle"><code class="docutils literal notranslate"><span class="pre">Group.is_vertex_in_cycle()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.make_sample_molecule"><code class="docutils literal notranslate"><span class="pre">Group.make_sample_molecule()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.merge"><code class="docutils literal notranslate"><span class="pre">Group.merge()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.merge_groups"><code class="docutils literal notranslate"><span class="pre">Group.merge_groups()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.pick_wildcards"><code class="docutils literal notranslate"><span class="pre">Group.pick_wildcards()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.remove_atom"><code class="docutils literal notranslate"><span class="pre">Group.remove_atom()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.remove_bond"><code class="docutils literal notranslate"><span class="pre">Group.remove_bond()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.remove_edge"><code class="docutils literal notranslate"><span class="pre">Group.remove_edge()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.remove_van_der_waals_bonds"><code class="docutils literal notranslate"><span class="pre">Group.remove_van_der_waals_bonds()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.remove_vertex"><code class="docutils literal notranslate"><span class="pre">Group.remove_vertex()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.reset_connectivity_values"><code class="docutils literal notranslate"><span class="pre">Group.reset_connectivity_values()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.reset_ring_membership"><code class="docutils literal notranslate"><span class="pre">Group.reset_ring_membership()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.restore_vertex_order"><code class="docutils literal notranslate"><span class="pre">Group.restore_vertex_order()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.sort_atoms"><code class="docutils literal notranslate"><span class="pre">Group.sort_atoms()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.sort_by_connectivity"><code class="docutils literal notranslate"><span class="pre">Group.sort_by_connectivity()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.sort_cyclic_vertices"><code class="docutils literal notranslate"><span class="pre">Group.sort_cyclic_vertices()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.sort_vertices"><code class="docutils literal notranslate"><span class="pre">Group.sort_vertices()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.specify_atom_extensions"><code class="docutils literal notranslate"><span class="pre">Group.specify_atom_extensions()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.specify_bond_extensions"><code class="docutils literal notranslate"><span class="pre">Group.specify_bond_extensions()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.specify_external_new_bond_extensions"><code class="docutils literal notranslate"><span class="pre">Group.specify_external_new_bond_extensions()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.specify_internal_new_bond_extensions"><code class="docutils literal notranslate"><span class="pre">Group.specify_internal_new_bond_extensions()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.specify_ring_extensions"><code class="docutils literal notranslate"><span class="pre">Group.specify_ring_extensions()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.specify_unpaired_extensions"><code class="docutils literal notranslate"><span class="pre">Group.specify_unpaired_extensions()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.split"><code class="docutils literal notranslate"><span class="pre">Group.split()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.standardize_atomtype"><code class="docutils literal notranslate"><span class="pre">Group.standardize_atomtype()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.standardize_group"><code class="docutils literal notranslate"><span class="pre">Group.standardize_group()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.to_adjacency_list"><code class="docutils literal notranslate"><span class="pre">Group.to_adjacency_list()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.update_charge"><code class="docutils literal notranslate"><span class="pre">Group.update_charge()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.update_connectivity_values"><code class="docutils literal notranslate"><span class="pre">Group.update_connectivity_values()</span></code></a></li>
<li><a class="reference internal" href="#rmgpy.molecule.Group.update_fingerprint"><code class="docutils literal notranslate"><span class="pre">Group.update_fingerprint()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
        </div>
        <div class="menuitem">
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="groupbond.html"
                          title="previous chapter">rmgpy.molecule.GroupBond</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="resonance.html"
                          title="next chapter">rmgpy.molecule.resonance</a></p>
  </div>
        </div>
        <div class="menuitem">
<div role="note" aria-label="source link">
    <h3>This Page</h3>
        <ul class="this-page-menu">
            <li><a href="https://github.com/ReactionMechanismGenerator/RMG-Py/issues">Report A Bug</a></li>
            <li><a href="https://github.com/ReactionMechanismGenerator/RMG-Py/blob/main/documentation/source/reference/molecule/group.rst"
                   rel="nofollow">View Source</a></li>
        </ul>
</div>
        </div>
        <div class="menuitem">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="resonance.html" title="rmgpy.molecule.resonance"
             >next</a> |</li>
        <li class="right" >
          <a href="groupbond.html" title="rmgpy.molecule.GroupBond"
             >previous</a> |</li>
  <li><a href="https://rmg.mit.edu/">RMG</a> &raquo;</li>
  <li><a href="../../index.html">3.3.0 Documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" >RMG API Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >Molecular representations (<code class="xref py py-mod docutils literal notranslate"><span class="pre">rmgpy.molecule</span></code>)</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">rmgpy.molecule.Group</a></li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2002-2025, William H. Green, Richard H. West, and the RMG Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.3.0.
    </div>
<script type="text/javascript">
  var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
  document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
  try {
    var pageTracker = _gat._getTracker("UA-24556433-3");
    pageTracker._trackPageview();
  } catch(err) {}
</script>

  </body>
</html>